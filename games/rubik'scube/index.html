<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>3D Rubik’s Cube + Solver — Manual Moves + User Moves Dropdown</title>

    <!-- Favicon (simple inline svg) -->
    <link
      rel="icon"
      type="image/svg+xml"
      href='data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><rect x="2" y="2" width="60" height="60" rx="14" fill="%23fff7e6" stroke="%23eadcc5" stroke-width="2"/><rect x="12" y="18" width="40" height="18" rx="9" fill="%23f59e0b"/><rect x="22" y="28" width="20" height="20" rx="5" fill="%23111827"/><g transform="translate(26 32)"><rect x="0" y="0" width="4" height="4" fill="%23fff"/><rect x="5" y="0" width="4" height="4" fill="%23f59e0b"/><rect x="10" y="0" width="4" height="4" fill="%2300a651"/><rect x="0" y="5" width="4" height="4" fill="%23b71234"/><rect x="5" y="5" width="4" height="4" fill="%230047ab"/><rect x="10" y="5" width="4" height="4" fill="%23ffd500"/></g></svg>'
    />

    <style>
      :root {
        --bg: #fff7e6;
        --card: #ffffff;
        --ink: #1f2937;
        --muted: #6b7280;
        --brand: #d97706;
        --brand2: #f59e0b;
        --border: #eadcc5;
        --shadow: 0 18px 40px rgba(31, 41, 55, 0.14);
        --codebg: #111827;
        --codeink: #e5e7eb;
        --ok: #166534;
        --warn: #92400e;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica,
          Arial, sans-serif;
        color: var(--ink);
        background: radial-gradient(
          900px 420px at 20% 0%,
          #fff1d6 0%,
          var(--bg) 55%,
          #fffaf1 100%
        );
      }
      header {
        position: sticky;
        top: 0;
        z-index: 5;
        padding: 12px 14px;
        background: linear-gradient(135deg, #fff 0%, #fff7ea 60%, #fff 100%);
        border-bottom: 1px solid var(--border);
        box-shadow: var(--shadow);
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        gap: 12px;
      }
      h1 {
        margin: 0;
        font-size: 16px;
        color: var(--brand);
        line-height: 1.2;
      }
      .sub {
        margin: 4px 0 0;
        font-size: 12px;
        color: var(--muted);
      }
      .badge {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 8px 10px;
        border-radius: 999px;
        background: #fff1d6;
        border: 1px solid var(--border);
        font-weight: 800;
        font-size: 12px;
        color: #7a4b00;
        white-space: nowrap;
      }
      .dot {
        width: 9px;
        height: 9px;
        border-radius: 99px;
        background: var(--brand2);
        box-shadow: 0 0 0 3px rgba(245, 158, 11, 0.2);
      }
      .wrap {
        max-width: 1200px;
        margin: 14px auto 26px;
        padding: 0 14px;
        display: grid;
        grid-template-columns: 1.7fr 1fr;
        gap: 14px;
      }
      @media (max-width: 980px) {
        .wrap {
          grid-template-columns: 1fr;
        }
      }
      .card {
        background: var(--card);
        border: 1px solid var(--border);
        border-radius: 18px;
        box-shadow: var(--shadow);
        overflow: hidden;
      }
      .controls {
        padding: 12px 14px;
        border-bottom: 1px solid var(--border);
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        align-items: center;
      }
      button {
        appearance: none;
        border: 1px solid var(--border);
        background: linear-gradient(180deg, #fff 0%, #fff5df 100%);
        color: var(--ink);
        border-radius: 12px;
        padding: 9px 11px;
        font-weight: 800;
        cursor: pointer;
        box-shadow: 0 8px 18px rgba(31, 41, 55, 0.1);
      }
      button.primary {
        border-color: rgba(217, 119, 6, 0.45);
        background: linear-gradient(180deg, #fffbf2 0%, #ffe5b4 100%);
      }
      button.ghost {
        box-shadow: none;
        background: #fff;
      }
      button:disabled {
        opacity: 0.55;
        cursor: not-allowed;
        box-shadow: none;
      }
      #stage {
        height: 560px;
        background: radial-gradient(
          1200px 500px at 50% 15%,
          #ffffff 0%,
          #fff7ea 40%,
          #fff3dd 100%
        );
      }
      @media (max-width: 980px) {
        #stage {
          height: 520px;
        }
      }

      .sideHead {
        padding: 12px 14px;
        border-bottom: 1px solid var(--border);
        background: linear-gradient(135deg, #fff 0%, #fff7ea 60%, #fff 100%);
      }
      .sideHead h2 {
        margin: 0;
        font-size: 14px;
        color: var(--brand);
      }
      .sideBody {
        padding: 12px 14px;
      }
      .row {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        align-items: center;
        justify-content: space-between;
      }
      .pill {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 8px 10px;
        border-radius: 999px;
        background: #fff;
        border: 1px solid var(--border);
        font-size: 12px;
        color: var(--muted);
      }
      .k {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace;
        font-size: 12px;
        padding: 2px 8px;
        border-radius: 999px;
        border: 1px solid var(--border);
        background: #fff7ea;
        color: #7a4b00;
        font-weight: 800;
      }
      .grid2 {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
        margin-top: 10px;
      }
      @media (max-width: 520px) {
        .grid2 {
          grid-template-columns: 1fr;
        }
      }
      .label {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        font-size: 12px;
        font-weight: 800;
        color: var(--muted);
        margin-bottom: 6px;
      }
      input[type="range"] {
        width: 100%;
      }

      .panel {
        margin-top: 12px;
        border: 1px solid var(--border);
        border-radius: 14px;
        overflow: hidden;
        background: #fff;
      }
      .panelHead {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        padding: 10px 12px;
        border-bottom: 1px solid var(--border);
        background: linear-gradient(135deg, #fff 0%, #fff7ea 60%, #fff 100%);
      }
      .panelHead b {
        color: var(--brand);
        font-size: 12.5px;
      }
      .panelBody {
        padding: 10px 12px;
      }
      .mono {
        background: var(--codebg);
        color: var(--codeink);
        border-radius: 12px;
        padding: 10px 10px;
        border: 1px solid rgba(234, 220, 197, 0.35);
        white-space: pre-wrap;
        word-break: break-word;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace;
        font-size: 12.2px;
        line-height: 1.45;
        min-height: 62px;
      }

      details {
        border: 1px solid var(--border);
        border-radius: 12px;
        overflow: hidden;
        background: #fff;
        margin-top: 10px;
      }
      details > summary {
        list-style: none;
        cursor: pointer;
        padding: 10px 12px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        font-weight: 900;
        color: var(--brand);
        background: linear-gradient(135deg, #fff 0%, #fff7ea 60%, #fff 100%);
        border-bottom: 1px solid var(--border);
      }
      details > summary::-webkit-details-marker {
        display: none;
      }
      .stepsBody {
        padding: 10px 12px;
      }
      .chips {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: center;
      }
      .chip {
        border: 1px solid var(--border);
        border-radius: 999px;
        padding: 6px 10px;
        background: #fff;
        font-weight: 900;
        font-size: 12px;
        cursor: pointer;
        box-shadow: 0 8px 18px rgba(31, 41, 55, 0.08);
      }
      .chip.active {
        border-color: rgba(245, 158, 11, 0.8);
        background: #fff1d6;
      }
      .tiny {
        font-size: 12px;
        color: var(--muted);
        line-height: 1.45;
      }
      .tiny code {
        background: #fff;
        border: 1px solid var(--border);
        padding: 1px 6px;
        border-radius: 10px;
      }
      .ok {
        color: var(--ok);
        font-weight: 900;
      }
      .warn {
        color: var(--warn);
        font-weight: 900;
      }
    </style>

    <script src="https://unpkg.com/three@0.149.0/build/three.min.js"></script>
    <script src="https://ldez.github.io/cubejs/lib/cube.js"></script>
    <script src="https://ldez.github.io/cubejs/lib/solve.js"></script>
  </head>

  <body>
    <header>
      <div>
        <h1>3D Rubik’s Cube + Solver</h1>
        <div class="sub">
          Manual move buttons → stored in a separate “User moves” dropdown.
        </div>
      </div>
      <div class="badge"><span class="dot"></span> Programmer's Picnic</div>
    </header>

    <div class="wrap">
      <section class="card">
        <div class="controls">
          <button class="primary" id="btnInit">Init Solver</button>
          <button class="primary" id="btnScramble" disabled>Scramble</button>
          <button class="primary" id="btnSolve" disabled>Solve</button>
          <button id="btnStep" disabled>Step</button>
          <button id="btnPlay" disabled>Play</button>
          <button class="ghost" id="btnReset">Reset</button>
        </div>
        <div id="stage"></div>
      </section>

      <aside class="card">
        <div class="sideHead"><h2>Status, Steps & Help</h2></div>
        <div class="sideBody">
          <div class="row">
            <div class="pill">
              Solver: <span class="k" id="solverState">not initialized</span>
            </div>
            <div class="pill">
              Busy: <span class="k" id="busy">no</span> • Queue:
              <span class="k" id="qCount">0</span>
            </div>
          </div>

          <!-- sliders hidden but still functional -->
          <div class="grid2">
            <div style="visibility: hidden">
              <div class="label">
                Animation speed <span class="k" id="speedTag">280ms</span>
              </div>
              <input id="speed" type="range" min="120" max="650" value="280" />
            </div>
            <div style="visibility: hidden">
              <div class="label">
                Scramble length <span class="k" id="scrTag">20</span>
              </div>
              <input id="scrLen" type="range" min="5" max="35" value="20" />
            </div>
          </div>

          <!-- ✅ Cube Color Theme Selector -->
          <div class="panel">
            <div class="panelHead">
              <b>Cube color theme</b>
              <span class="k">Visual</span>
            </div>
            <div class="panelBody">
              <div class="chips" id="themeSelector"></div>
              <div class="tiny" style="margin-top: 6px">
                Changes only cube appearance. Solver logic stays the same.
              </div>
            </div>
          </div>

          <div class="panel">
            <div class="panelHead">
              <b>Current queue</b>
              <button class="ghost" id="btnCopyQueue">Copy</button>
            </div>
            <div class="panelBody">
              <div class="mono" id="movesBox">—</div>
            </div>
          </div>

          <!-- Manual Moves -->
          <div class="panel">
            <div class="panelHead">
              <b>Manual moves</b>
              <span class="k">Click</span>
            </div>
            <div class="panelBody">
              <div class="tiny">
                Tap a move to apply it immediately (saved into
                <b>User moves</b>).
              </div>
              <div class="chips" id="manualMoves"></div>
            </div>
          </div>

          <!-- User Moves Dropdown -->
          <details id="userDetails">
            <summary>
              <span>User moves</span><span class="k" id="userCount">0</span>
            </summary>
            <div class="stepsBody">
              <div class="tiny">
                Moves you made manually. Click any move to preview explanation.
              </div>
              <div class="chips" id="userChips"></div>
            </div>
          </details>

          <details id="scrambleDetails">
            <summary>
              <span>Scramble steps</span
              ><span class="k" id="scrambleCount">0</span>
            </summary>
            <div class="stepsBody">
              <div class="tiny">
                Moves used for the last scramble. Click to preview.
              </div>
              <div class="chips" id="scrambleChips"></div>
            </div>
          </details>

          <details id="solveDetails">
            <summary>
              <span>Solving steps</span><span class="k" id="solveCount">0</span>
            </summary>
            <div class="stepsBody">
              <div class="tiny">
                Solution moves. Use <b>Step</b> / <b>Play</b> to execute.
              </div>
              <div class="chips" id="solveChips"></div>
            </div>
          </details>

          <div class="panel">
            <div class="panelHead">
              <b>Move explanation</b><span class="k">Live</span>
            </div>
            <div class="panelBody">
              <div class="mono" id="moveExplain">
                No move yet. Use Scramble, Step, Play, or Manual moves.
              </div>
            </div>
          </div>

          <div class="panel">
            <div class="panelHead">
              <b>Help</b><span class="k">Quick guide</span>
            </div>
            <div class="panelBody">
              <div class="tiny">
                <div>
                  <span class="ok">1)</span> Click
                  <b>Init Solver</b> (one-time).
                </div>
                <div>
                  <span class="ok">2)</span> Click <b>Scramble</b> then
                  <b>Solve</b>.
                </div>
                <div>
                  <span class="ok">3)</span> Click <b>Play</b> to animate the
                  solution.
                </div>

                <div style="margin-top: 8px">
                  <span class="warn">Manual:</span> tap <code>R</code>,
                  <code>U'</code>, <code>F2</code> etc.
                </div>

                <div style="margin-top: 8px">
                  <span class="warn">Rotate view:</span> drag inside the cube
                  area.
                </div>

                <div style="margin-top: 10px">
                  <span class="warn">Move notation explained:</span>
                  <div style="margin-top: 6px">
                    <div>
                      <code>R</code> = turn the <b>Right</b> face
                      <b>clockwise</b> 90°
                    </div>
                    <div>
                      <code>R'</code> = turn the Right face
                      <b>counter-clockwise</b> 90°
                    </div>
                    <div>
                      <code>R2</code> = turn the Right face <b>180°</b> (two
                      quarter-turns)
                    </div>

                    <div style="margin-top: 8px">
                      Faces:
                      <code>R</code>=Right, <code>L</code>=Left,
                      <code>U</code>=Up (Top), <code>D</code>=Down (Bottom),
                      <code>F</code>=Front, <code>B</code>=Back
                    </div>

                    <div style="margin-top: 8px">
                      Rule: “Clockwise” means
                      <b>as if you are looking directly at that face</b>.
                    </div>

                    <div style="margin-top: 8px">
                      Examples:
                      <code>R U R' U'</code> (a common 4-move sequence)<br />
                      <code>F2 U2</code> (Front 180°, then Up 180°)
                    </div>
                  </div>
                </div>

                <div style="margin-top: 10px">
                  <span class="warn">Standard cube colors:</span>
                  <div style="margin-top: 6px">
                    <code>U</code> White • <code>D</code> Yellow •
                    <code>F</code> Green • <code>B</code> Blue •
                    <code>R</code> Red • <code>L</code> Orange
                  </div>
                </div>
              </div>
            </div>
          </div>

          <div class="tiny" style="margin-top: 10px"></div>
        </div>
      </aside>
    </div>

    <script>
      /* =========================
         DOM helpers
      ========================= */
      const $ = (id) => document.getElementById(id);

      const btnInit = $("btnInit");
      const btnScramble = $("btnScramble");
      const btnSolve = $("btnSolve");
      const btnStep = $("btnStep");
      const btnPlay = $("btnPlay");
      const btnReset = $("btnReset");
      const btnCopyQueue = $("btnCopyQueue");

      const solverState = $("solverState");
      const busyEl = $("busy");
      const qCountEl = $("qCount");
      const movesBox = $("movesBox");

      const speed = $("speed");
      const scrLen = $("scrLen");
      const speedTag = $("speedTag");
      const scrTag = $("scrTag");

      const moveExplainBox = $("moveExplain");

      const manualMoves = $("manualMoves");
      const userDetails = $("userDetails");
      const userChips = $("userChips");
      const userCount = $("userCount");

      const scrambleDetails = $("scrambleDetails");
      const solveDetails = $("solveDetails");

      const scrambleChips = $("scrambleChips");
      const solveChips = $("solveChips");
      const scrambleCount = $("scrambleCount");
      const solveCount = $("solveCount");

      const themeSelector = $("themeSelector");

      function setBusy(v) {
        busyEl.textContent = v ? "yes" : "no";
      }
      function setQueueCount(n) {
        qCountEl.textContent = String(n);
      }
      function setMovesText(t) {
        movesBox.textContent = t || "—";
      }
      function setSolverText(t) {
        solverState.textContent = t;
      }

      function refreshLabels() {
        speedTag.textContent = `${Number(speed.value)}ms`;
        scrTag.textContent = `${Number(scrLen.value)}`;
      }
      speed.addEventListener("input", refreshLabels);
      scrLen.addEventListener("input", refreshLabels);
      refreshLabels();

      /* =========================
         Move explanation
      ========================= */
      function explainMove(move) {
        if (!move) {
          moveExplainBox.textContent =
            "No move yet. Use Scramble, Step, Play, or Manual moves.";
          return;
        }
        const faceMap = {
          R: "Right face",
          L: "Left face",
          U: "Top (Up) face",
          D: "Bottom (Down) face",
          F: "Front face",
          B: "Back face",
        };
        const face = move[0];
        let direction = "clockwise";
        let degrees = "90°";
        if (move.endsWith("'")) direction = "counter-clockwise";
        if (move.endsWith("2")) {
          degrees = "180°";
          direction = "clockwise";
        }
        moveExplainBox.textContent = `${move}\n\nRotate the ${faceMap[face]} ${direction} by ${degrees}.`;
      }

      /* =========================
         Three.js scene
      ========================= */
      const stage = $("stage");
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xfff7e6);

      const camera = new THREE.PerspectiveCamera(
        45,
        stage.clientWidth / stage.clientHeight,
        0.1,
        100
      );
      camera.position.set(6, 6, 8);
      camera.lookAt(0, 0, 0);

      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: false,
      });
      renderer.setSize(stage.clientWidth, stage.clientHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      stage.appendChild(renderer.domElement);

      scene.add(new THREE.AmbientLight(0xffffff, 0.65));
      const sun = new THREE.DirectionalLight(0xffffff, 0.9);
      sun.position.set(6, 8, 6);
      scene.add(sun);

      /* drag rotate */
      let isDragging = false,
        prevX = 0,
        prevY = 0;
      renderer.domElement.addEventListener("mousedown", (e) => {
        isDragging = true;
        prevX = e.clientX;
        prevY = e.clientY;
      });
      window.addEventListener("mouseup", () => {
        isDragging = false;
      });
      window.addEventListener("mousemove", (e) => {
        if (!isDragging) return;
        const dx = e.clientX - prevX;
        const dy = e.clientY - prevY;
        scene.rotation.y += dx * 0.006;
        scene.rotation.x += dy * 0.006;
        prevX = e.clientX;
        prevY = e.clientY;
      });

      /* =========================
         3D cube groups + overlays
      ========================= */
      const cubeGroup = new THREE.Group();
      scene.add(cubeGroup);

      const SIZE = 1,
        GAP = 0.06,
        STEP = SIZE + GAP;
      const FACE_SIZE = 3 * STEP - GAP;
      const HILITE_OFFSET = STEP * 1.5 + 0.02;

      /* overlays */
      const highlightPlane = new THREE.Mesh(
        new THREE.PlaneGeometry(FACE_SIZE, FACE_SIZE),
        new THREE.MeshBasicMaterial({
          color: 0xf59e0b,
          transparent: true,
          opacity: 0.18,
          side: THREE.DoubleSide,
          depthWrite: false,
        })
      );
      highlightPlane.visible = false;
      cubeGroup.add(highlightPlane);

      const arrowGroup = new THREE.Group();
      arrowGroup.visible = false;
      cubeGroup.add(arrowGroup);

      function clearArrows() {
        while (arrowGroup.children.length)
          arrowGroup.remove(arrowGroup.children[0]);
      }
      function setFaceOverlays(move) {
        if (!move) {
          highlightPlane.visible = false;
          arrowGroup.visible = false;
          return;
        }
        const face = move[0];
        let turns = 1,
          dir = 1;
        if (move.endsWith("2")) turns = 2;
        if (move.endsWith("'")) dir = -1;

        const map = {
          F: {
            n: new THREE.Vector3(0, 0, 1),
            u: new THREE.Vector3(1, 0, 0),
            v: new THREE.Vector3(0, 1, 0),
            pos: new THREE.Vector3(0, 0, HILITE_OFFSET),
            rot: new THREE.Euler(0, 0, 0),
          },
          B: {
            n: new THREE.Vector3(0, 0, -1),
            u: new THREE.Vector3(-1, 0, 0),
            v: new THREE.Vector3(0, 1, 0),
            pos: new THREE.Vector3(0, 0, -HILITE_OFFSET),
            rot: new THREE.Euler(0, Math.PI, 0),
          },
          R: {
            n: new THREE.Vector3(1, 0, 0),
            u: new THREE.Vector3(0, 0, -1),
            v: new THREE.Vector3(0, 1, 0),
            pos: new THREE.Vector3(HILITE_OFFSET, 0, 0),
            rot: new THREE.Euler(0, -Math.PI / 2, 0),
          },
          L: {
            n: new THREE.Vector3(-1, 0, 0),
            u: new THREE.Vector3(0, 0, 1),
            v: new THREE.Vector3(0, 1, 0),
            pos: new THREE.Vector3(-HILITE_OFFSET, 0, 0),
            rot: new THREE.Euler(0, Math.PI / 2, 0),
          },
          U: {
            n: new THREE.Vector3(0, 1, 0),
            u: new THREE.Vector3(1, 0, 0),
            v: new THREE.Vector3(0, 0, -1),
            pos: new THREE.Vector3(0, HILITE_OFFSET, 0),
            rot: new THREE.Euler(-Math.PI / 2, 0, 0),
          },
          D: {
            n: new THREE.Vector3(0, -1, 0),
            u: new THREE.Vector3(1, 0, 0),
            v: new THREE.Vector3(0, 0, 1),
            pos: new THREE.Vector3(0, -HILITE_OFFSET, 0),
            rot: new THREE.Euler(Math.PI / 2, 0, 0),
          },
        }[face];

        if (!map) {
          highlightPlane.visible = false;
          arrowGroup.visible = false;
          return;
        }

        highlightPlane.position.copy(map.pos);
        highlightPlane.rotation.copy(map.rot);
        highlightPlane.visible = true;

        clearArrows();
        arrowGroup.visible = true;

        const baseLen = FACE_SIZE * 0.38;
        const headLen = baseLen * 0.22;
        const headWid = baseLen * 0.18;

        const arrowDir =
          dir === 1 ? map.u.clone() : map.u.clone().multiplyScalar(-1);
        const origin = map.pos
          .clone()
          .add(map.v.clone().multiplyScalar(FACE_SIZE * 0.32))
          .add(map.n.clone().multiplyScalar(0.02));
        arrowGroup.add(
          new THREE.ArrowHelper(
            arrowDir.clone().normalize(),
            origin,
            baseLen,
            0xf59e0b,
            headLen,
            headWid
          )
        );

        if (turns === 2) {
          const origin2 = map.pos
            .clone()
            .add(map.v.clone().multiplyScalar(-FACE_SIZE * 0.32))
            .add(map.n.clone().multiplyScalar(0.02));
          arrowGroup.add(
            new THREE.ArrowHelper(
              arrowDir.clone().normalize(),
              origin2,
              baseLen,
              0xf59e0b,
              headLen,
              headWid
            )
          );
        }
      }

      /* =========================
         Cube color themes
      ========================= */
      const COLOR_THEMES = {
        standard: {
          name: "Standard (WCA)",
          U: 0xffffff, // white
          D: 0xffd500, // yellow
          F: 0x00a651, // green
          B: 0x0047ab, // blue
          R: 0xb71234, // red
          L: 0xff6a00, // orange
          K: 0x111111, // core
        },
        pastel: {
          name: "Pastel",
          U: 0xfdfdfd,
          D: 0xfff1a8,
          F: 0x8ee6b8,
          B: 0x9bbcff,
          R: 0xff9aa2,
          L: 0xffcba4,
          K: 0x222222,
        },
        highContrast: {
          name: "High Contrast",
          U: 0xffffff,
          D: 0xffff00,
          F: 0x00ff00,
          B: 0x0000ff,
          R: 0xff0000,
          L: 0xff8800,
          K: 0x000000,
        },
        darkMode: {
          name: "Dark Mode",
          U: 0xe5e7eb,
          D: 0xfacc15,
          F: 0x22c55e,
          B: 0x3b82f6,
          R: 0xef4444,
          L: 0xfb923c,
          K: 0x020617,
        },
      };

      let activeTheme = "standard";
      let COLORS = COLOR_THEMES[activeTheme];

      /* =========================
         Build cubies (uses COLORS)
      ========================= */
      let cubies = [];

      function createCubie(x, y, z) {
        const cube = new THREE.Mesh(
          new THREE.BoxGeometry(SIZE, SIZE, SIZE),
          new THREE.MeshStandardMaterial({
            color: COLORS.K,
            roughness: 0.55,
            metalness: 0.05,
          })
        );
        cube.position.set(x * STEP, y * STEP, z * STEP);
        cube.userData = { x, y, z };

        const plane = new THREE.PlaneGeometry(0.9, 0.9);
        const o = SIZE / 2 + 0.01;

        function sticker(color, pos, rot) {
          const s = new THREE.Mesh(
            plane,
            new THREE.MeshStandardMaterial({
              color,
              roughness: 0.35,
              metalness: 0.02,
            })
          );
          s.position.copy(pos);
          s.rotation.set(rot.x, rot.y, rot.z);
          cube.add(s);
        }

        if (y === 1)
          sticker(
            COLORS.U,
            new THREE.Vector3(0, o, 0),
            new THREE.Euler(-Math.PI / 2, 0, 0)
          );
        if (y === -1)
          sticker(
            COLORS.D,
            new THREE.Vector3(0, -o, 0),
            new THREE.Euler(Math.PI / 2, 0, 0)
          );
        if (z === 1)
          sticker(
            COLORS.F,
            new THREE.Vector3(0, 0, o),
            new THREE.Euler(0, 0, 0)
          );
        if (z === -1)
          sticker(
            COLORS.B,
            new THREE.Vector3(0, 0, -o),
            new THREE.Euler(0, Math.PI, 0)
          );
        if (x === 1)
          sticker(
            COLORS.R,
            new THREE.Vector3(o, 0, 0),
            new THREE.Euler(0, -Math.PI / 2, 0)
          );
        if (x === -1)
          sticker(
            COLORS.L,
            new THREE.Vector3(-o, 0, 0),
            new THREE.Euler(0, Math.PI / 2, 0)
          );

        return cube;
      }

      function buildCube() {
        for (const c of cubies) cubeGroup.remove(c);
        cubies = [];

        for (let x = -1; x <= 1; x++)
          for (let y = -1; y <= 1; y++)
            for (let z = -1; z <= 1; z++) {
              const c = createCubie(x, y, z);
              cubies.push(c);
              cubeGroup.add(c);
            }
      }

      /* =========================
         cube.js model + solver + move queues
      ========================= */
      let solverReady = false;
      let model = new Cube();
      let queue = [];
      let playing = false;
      let animating = false;

      let lastUserMoves = [];
      let lastScrambleMoves = [];
      let lastSolveMoves = [];
      let currentStepMove = null;

      // ✅ full history of moves that created the CURRENT cube state
      // used to rebuild visuals after theme change
      let historyMoves = [];

      function refreshQueueButtons() {
        const hasQueue = queue.length > 0;
        btnStep.disabled = !solverReady || !hasQueue || animating;
        btnPlay.disabled = !solverReady || !hasQueue || animating;
      }
      function enableControls(ready) {
        btnScramble.disabled = !ready;
        btnSolve.disabled = !ready;
        refreshQueueButtons();
      }
      function updateQueueUI(prefix = "") {
        const preview = queue.slice(0, 90).join(" ");
        const more = queue.length > 90 ? ` … (+${queue.length - 90} more)` : "";
        const text = prefix
          ? `${prefix}\n\n${preview ? preview + more : "—"}`
          : preview
          ? preview + more
          : "—";
        setMovesText(text);
        setQueueCount(queue.length);
        refreshQueueButtons();
      }
      function randomScramble(n) {
        const faces = ["R", "L", "U", "D", "F", "B"];
        const suf = ["", "'", "2"];
        const out = [];
        let last = "";
        while (out.length < n) {
          const f = faces[(Math.random() * 6) | 0];
          if (f === last) continue;
          last = f;
          out.push(f + suf[(Math.random() * 3) | 0]);
        }
        return out;
      }
      function cloneModel() {
        return Cube.fromString(model.asString());
      }

      /* =========================
         Steps dropdown UI
      ========================= */
      function renderChips(container, moves, activeMove) {
        container.innerHTML = "";
        if (!moves.length) {
          const span = document.createElement("div");
          span.className = "tiny";
          span.textContent = "(none)";
          container.appendChild(span);
          return;
        }
        moves.forEach((mv, idx) => {
          const b = document.createElement("button");
          b.type = "button";
          b.className = "chip" + (mv === activeMove ? " active" : "");
          b.textContent = `${idx + 1}. ${mv}`;
          b.addEventListener("click", () => {
            currentStepMove = mv;
            explainMove(mv);
            setFaceOverlays(mv);
            [...container.querySelectorAll(".chip")].forEach((x) =>
              x.classList.remove("active")
            );
            b.classList.add("active");
          });
          container.appendChild(b);
        });
      }
      function refreshStepsUI() {
        userCount.textContent = String(lastUserMoves.length);
        scrambleCount.textContent = String(lastScrambleMoves.length);
        solveCount.textContent = String(lastSolveMoves.length);

        renderChips(userChips, lastUserMoves, currentStepMove);
        renderChips(scrambleChips, lastScrambleMoves, currentStepMove);
        renderChips(solveChips, lastSolveMoves, currentStepMove);
      }

      /* =========================
         Move mapping (keeps solve/play correct)
      ========================= */
      function faceAxisAndLayer(face) {
        switch (face) {
          case "R":
            return { axis: new THREE.Vector3(1, 0, 0), k: "x", v: 1 };
          case "L":
            return { axis: new THREE.Vector3(1, 0, 0), k: "x", v: -1 };
          case "U":
            return { axis: new THREE.Vector3(0, 1, 0), k: "y", v: 1 };
          case "D":
            return { axis: new THREE.Vector3(0, 1, 0), k: "y", v: -1 };
          case "F":
            return { axis: new THREE.Vector3(0, 0, 1), k: "z", v: 1 };
          case "B":
            return { axis: new THREE.Vector3(0, 0, 1), k: "z", v: -1 };
        }
      }
      function computeAngle(move) {
        const face = move[0];
        const { axis, k, v } = faceAxisAndLayer(face);

        let turns = 1;
        if (move.endsWith("2")) turns = 2;

        let dir = move.endsWith("'") ? -1 : 1;

        // correction for world coordinates
        if (face === "L" || face === "D" || face === "B") dir *= -1;

        const angle = dir * (Math.PI / 2) * turns;
        return { info: { a: axis, k, v }, turns, angle };
      }

      function snapCubie(c) {
        c.userData = {
          x: Math.round(c.position.x / STEP),
          y: Math.round(c.position.y / STEP),
          z: Math.round(c.position.z / STEP),
        };
        c.position.set(
          c.userData.x * STEP,
          c.userData.y * STEP,
          c.userData.z * STEP
        );
      }

      function applyTurnInstant(move) {
        const { info, angle } = computeAngle(move);
        const layer = cubies.filter((c) => c.userData[info.k] === info.v);

        const g = new THREE.Group();
        cubeGroup.add(g);
        layer.forEach((c) => g.attach(c));

        g.setRotationFromAxisAngle(info.a, angle);
        g.updateMatrixWorld(true);

        layer.forEach((c) => {
          c.applyMatrix4(g.matrix);
          cubeGroup.attach(c);
          snapCubie(c);
        });

        cubeGroup.remove(g);
      }

      async function animateTurn(move) {
        const { info, turns, angle } = computeAngle(move);
        const layer = cubies.filter((c) => c.userData[info.k] === info.v);

        const g = new THREE.Group();
        cubeGroup.add(g);
        layer.forEach((c) => g.attach(c));

        const start = performance.now();
        const duration = Number(speed.value) * turns;

        animating = true;
        setBusy(true);
        refreshQueueButtons();

        await new Promise((res) => {
          function anim(now) {
            const p = Math.min(1, (now - start) / duration);
            const ease = p < 0.5 ? 2 * p * p : 1 - Math.pow(-2 * p + 2, 2) / 2;
            g.setRotationFromAxisAngle(info.a, angle * ease);
            if (p < 1) requestAnimationFrame(anim);
            else res();
          }
          requestAnimationFrame(anim);
        });

        g.updateMatrixWorld(true);
        layer.forEach((c) => {
          c.applyMatrix4(g.matrix);
          cubeGroup.attach(c);
          snapCubie(c);
        });
        cubeGroup.remove(g);

        animating = false;
        setBusy(false);
        refreshQueueButtons();
      }

      /* =========================
         Theme selector (rebuild visuals safely)
      ========================= */
      function rebuildToCurrentState() {
        // rebuild the meshes with new COLORS, then replay historyMoves instantly
        buildCube();
        model = new Cube();
        for (const mv of historyMoves) {
          model.move(mv);
          applyTurnInstant(mv);
        }
      }

      function applyColorTheme(themeKey) {
        activeTheme = themeKey;
        COLORS = COLOR_THEMES[themeKey];
        rebuildToCurrentState();
      }

      function buildThemeSelector() {
        themeSelector.innerHTML = "";
        Object.entries(COLOR_THEMES).forEach(([key, theme]) => {
          const b = document.createElement("button");
          b.type = "button";
          b.className = "chip" + (key === activeTheme ? " active" : "");
          b.textContent = theme.name;

          b.addEventListener("click", () => {
            [...themeSelector.querySelectorAll(".chip")].forEach((x) =>
              x.classList.remove("active")
            );
            b.classList.add("active");
            applyColorTheme(key);
          });

          themeSelector.appendChild(b);
        });
      }

      /* =========================
         Step / Play (executes SOLVE QUEUE)
      ========================= */
      async function stepOne() {
        if (animating) return;
        if (!queue.length) {
          setFaceOverlays(null);
          refreshQueueButtons();
          return;
        }

        const mv = queue.shift();

        currentStepMove = mv;
        explainMove(mv);
        setFaceOverlays(mv);

        model.move(mv);
        historyMoves.push(mv); // ✅ keep state history in sync
        await animateTurn(mv);

        updateQueueUI();
        refreshStepsUI();

        if (!queue.length) {
          setTimeout(() => setFaceOverlays(null), 280);
          explainMove(null);
        }
      }

      async function playAll() {
        playing = true;
        while (queue.length && playing) {
          await stepOne();
          await new Promise((r) => setTimeout(r, 20));
        }
        playing = false;
        btnPlay.textContent = "Play";
        refreshQueueButtons();
      }

      /* =========================
         Manual moves buttons (Option A)
      ========================= */
      function addManualMoveButtons() {
        const faces = ["R", "L", "U", "D", "F", "B"];
        const mods = ["", "'", "2"];

        manualMoves.innerHTML = "";

        for (const f of faces) {
          for (const m of mods) {
            const mv = f + m;
            const b = document.createElement("button");
            b.type = "button";
            b.className = "chip";
            b.textContent = mv;

            b.addEventListener("click", async () => {
              if (!solverReady) return;
              if (animating) return;

              // stop play mode, keep solve queue intact
              playing = false;
              btnPlay.textContent = "Play";

              currentStepMove = mv;
              explainMove(mv);
              setFaceOverlays(mv);

              model.move(mv);
              historyMoves.push(mv); // ✅ keep state history in sync
              await animateTurn(mv);

              lastUserMoves.push(mv);
              userDetails.open = true;
              refreshStepsUI();

              if (!queue.length)
                updateQueueUI("Manual move applied. (No queued solution)");
              else updateQueueUI();
            });

            manualMoves.appendChild(b);
          }
        }
      }

      /* =========================
         Copy
      ========================= */
      async function copyText(text) {
        try {
          await navigator.clipboard.writeText(text);
        } catch {
          const ta = document.createElement("textarea");
          ta.value = text;
          document.body.appendChild(ta);
          ta.select();
          document.execCommand("copy");
          ta.remove();
        }
      }
      btnCopyQueue.addEventListener("click", () => {
        const t = movesBox.textContent.trim();
        if (!t || t === "—") return;
        copyText(t);
      });

      /* =========================
         Init + buttons
      ========================= */
      function setInitialUI() {
        setSolverText("not initialized");
        setBusy(false);

        queue = [];
        lastUserMoves = [];
        lastScrambleMoves = [];
        lastSolveMoves = [];
        currentStepMove = null;

        historyMoves = []; // ✅
        updateQueueUI();
        refreshStepsUI();
        explainMove(null);
        setFaceOverlays(null);
        enableControls(false);
      }

      buildCube();
      setInitialUI();
      addManualMoveButtons();
      buildThemeSelector();

      btnInit.addEventListener("click", () => {
        if (solverReady) return;

        btnInit.disabled = true;
        enableControls(false);
        setSolverText("initializing…");
        setBusy(true);

        setTimeout(() => {
          try {
            Cube.initSolver();
            solverReady = true;
            setSolverText("ready ✅");
            enableControls(true);
          } catch (e) {
            console.error(e);
            setSolverText("init failed ❌ (see console)");
            btnInit.disabled = false;
          } finally {
            setBusy(false);
            refreshQueueButtons();
          }
        }, 50);
      });

      btnScramble.addEventListener("click", () => {
        if (!solverReady || animating) return;

        playing = false;
        btnPlay.textContent = "Play";

        queue = [];
        lastSolveMoves = [];
        lastUserMoves = [];

        model = new Cube();
        historyMoves = []; // ✅ reset history
        buildCube();

        const n = Number(scrLen.value);
        const scr = randomScramble(n);
        lastScrambleMoves = scr.slice();

        for (const mv of scr) {
          model.move(mv);
          historyMoves.push(mv); // ✅
          applyTurnInstant(mv);
        }

        currentStepMove = scr[scr.length - 1] || null;
        explainMove(currentStepMove);
        setFaceOverlays(currentStepMove);

        updateQueueUI(`Scrambled (${n} moves).`);
        setSolverText("ready ✅ (scrambled)");
        refreshStepsUI();

        scrambleDetails.open = true;
        solveDetails.open = false;
        userDetails.open = false;
      });

      btnSolve.addEventListener("click", () => {
        if (!solverReady || animating) return;

        setSolverText("solving…");
        setBusy(true);
        enableControls(false);

        setTimeout(() => {
          try {
            const clone = cloneModel();
            const alg = clone.solve();

            queue = alg.trim().split(/\s+/).filter(Boolean);
            lastSolveMoves = queue.slice();

            currentStepMove = queue[0] || null;
            explainMove(currentStepMove);
            setFaceOverlays(currentStepMove);

            updateQueueUI(`Solution loaded (${queue.length} moves).`);
            setSolverText(`ready ✅ (solution: ${queue.length})`);
            refreshStepsUI();

            solveDetails.open = true;
            scrambleDetails.open = false;
          } catch (e) {
            console.error(e);
            setSolverText("solve failed ❌ (see console)");
          } finally {
            setBusy(false);
            enableControls(true);
            refreshQueueButtons();
          }
        }, 10);
      });

      btnStep.addEventListener("click", () => {
        playing = false;
        btnPlay.textContent = "Play";
        stepOne();
      });

      btnPlay.addEventListener("click", () => {
        if (!solverReady || animating) return;
        if (!queue.length) return;

        if (playing) {
          playing = false;
          btnPlay.textContent = "Play";
          return;
        }
        btnPlay.textContent = "Pause";
        playAll();
      });

      btnReset.addEventListener("click", () => {
        playing = false;
        btnPlay.textContent = "Play";

        queue = [];
        model = new Cube();
        historyMoves = []; // ✅ reset
        buildCube();

        lastUserMoves = [];
        lastScrambleMoves = [];
        lastSolveMoves = [];
        currentStepMove = null;

        updateQueueUI();
        refreshStepsUI();
        explainMove(null);
        setFaceOverlays(null);
        setSolverText(solverReady ? "ready ✅" : "not initialized");
        refreshQueueButtons();
      });

      /* =========================
         Render loop + resize
      ========================= */
      function loop() {
        renderer.render(scene, camera);
        requestAnimationFrame(loop);
      }
      loop();

      window.addEventListener("resize", () => {
        const w = stage.clientWidth;
        const h = stage.clientHeight;
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        renderer.setSize(w, h);
      });
    </script>
  </body>
</html>
