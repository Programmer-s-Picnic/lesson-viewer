<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>JavaScript — Promises & Async/Await (with Embedded Editor)</title>
  <meta name="description" content="A comprehensive lesson on JavaScript Promises and async/await, leading to fetch + SWAPI. Includes an embedded JavaScript editor." />

  <style>
    :root{
      /* Light Saffron theme */
      --bg0:#fff7e6;
      --bg1:#fff1d6;
      --card:rgba(255,255,255,.9);
      --ink:#1f2937;
      --muted:#6b7280;
      --brand:#d97706;
      --brand2:#b45309;
      --border:rgba(31,41,55,.12);
      --shadow:0 12px 30px rgba(0,0,0,.08);
      --radius:18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Helvetica,Arial;
      --maxw: 1150px;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--ink);
      background:
        radial-gradient(900px 450px at 20% 10%, rgba(217,119,6,.18), transparent 60%),
        radial-gradient(800px 400px at 85% 12%, rgba(245,158,11,.16), transparent 60%),
        linear-gradient(180deg,var(--bg0),var(--bg1));
    }

    a{color:var(--brand2); text-decoration:none}
    a:hover{text-decoration:underline}

    .topbar{
      position:sticky; top:0; z-index:50;
      backdrop-filter: blur(10px);
      background: rgba(255,247,230,.75);
      border-bottom: 1px solid var(--border);
    }
    .topbar-inner{
      max-width:var(--maxw);
      margin:0 auto;
      padding:12px 16px;
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:space-between;
    }
    .brand{
      display:flex; gap:10px; align-items:center;
    }
    .logo{
      width:40px;height:40px;border-radius:12px;
      background: linear-gradient(135deg, rgba(217,119,6,.95), rgba(245,158,11,.85));
      box-shadow: 0 10px 22px rgba(217,119,6,.25);
      display:grid;place-items:center;
      color:#fff; font-weight:800;
      letter-spacing:.5px;
    }
    .brand h1{
      margin:0;
      font-size:16px;
      line-height:1.2;
    }
    .brand small{display:block; color:var(--muted); font-weight:600}

    .actions{
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
    }

    .pill{
      border:1px solid var(--border);
      background: rgba(255,255,255,.75);
      padding:8px 10px;
      border-radius:999px;
      font-size:12px;
      color:var(--muted);
      display:flex; gap:8px; align-items:center;
    }
    .btn{
      cursor:pointer;
      border:1px solid rgba(217,119,6,.35);
      background: linear-gradient(180deg, rgba(255,255,255,.9), rgba(255,255,255,.72));
      color:var(--brand2);
      padding:9px 12px;
      border-radius:12px;
      font-weight:700;
      box-shadow: 0 10px 20px rgba(0,0,0,.06);
      transition: transform .08s ease, box-shadow .12s ease;
      user-select:none;
    }
    .btn:active{ transform: translateY(1px); box-shadow: 0 8px 16px rgba(0,0,0,.06); }
    .btn.primary{
      border:1px solid rgba(217,119,6,.55);
      background: linear-gradient(180deg, rgba(217,119,6,.95), rgba(180,83,9,.95));
      color:#fff;
    }
    .btn.ghost{
      border:1px solid var(--border);
      background: rgba(255,255,255,.6);
      color:var(--ink);
      font-weight:700;
    }

    main{
      max-width:var(--maxw);
      margin:0 auto;
      padding:18px 16px 40px;
      display:grid;
      gap:16px;
    }

    .grid{
      display:grid;
      grid-template-columns: 1.05fr .95fr;
      gap:16px;
      align-items:start;
    }
    @media (max-width: 980px){
      .grid{ grid-template-columns: 1fr; }
    }

    .card{
      background: var(--card);
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }

    .card h2, .card h3{
      margin:0;
    }
    .card-head{
      padding:14px 14px 12px;
      border-bottom:1px solid var(--border);
      background: linear-gradient(180deg, rgba(255,255,255,.85), rgba(255,255,255,.72));
    }
    .card-head .kicker{
      font-size:12px;
      color:var(--muted);
      font-weight:700;
      letter-spacing:.3px;
      text-transform:uppercase;
    }
    .card-head h2{
      margin-top:6px;
      font-size:18px;
      line-height:1.25;
    }
    .card-body{
      padding:14px;
    }

    .toc{
      display:flex; flex-wrap:wrap; gap:8px;
      margin-top:10px;
    }
    .toc a{
      border:1px solid var(--border);
      background: rgba(255,255,255,.65);
      padding:8px 10px;
      border-radius:999px;
      font-size:12px;
      color:var(--ink);
      font-weight:700;
    }
    .toc a:hover{border-color: rgba(217,119,6,.35);}

    .note{
      padding:12px;
      border:1px solid rgba(217,119,6,.22);
      background: rgba(255, 248, 235, .75);
      border-radius: 14px;
      color: var(--ink);
    }
    .note b{ color: var(--brand2); }

    .codeblock{
      margin:12px 0 14px;
      border:1px solid var(--border);
      border-radius: 14px;
      overflow:hidden;
      background: rgba(255,255,255,.72);
    }
    .codebar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:10px 10px;
      border-bottom:1px solid var(--border);
      background: linear-gradient(180deg, rgba(255,255,255,.85), rgba(255,255,255,.72));
    }
    .codebar .title{
      font-size:12px;
      font-weight:800;
      color:var(--muted);
      letter-spacing:.2px;
    }
    pre{
      margin:0;
      padding:12px 12px;
      overflow:auto;
      font-family: var(--mono);
      font-size:12.7px;
      line-height:1.45;
      color:#0f172a;
      max-height: 310px;
      background: rgba(255,255,255,.66);
    }

    .mini{
      font-size:13px;
      color:var(--muted);
      line-height:1.55;
    }
    ul,ol{ margin: 8px 0 0 18px; padding:0; }
    li{ margin: 6px 0; }

    .split{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
    }
    @media (max-width: 700px){
      .split{ grid-template-columns: 1fr; }
    }

    .editorWrap{
      height: min(78vh, 860px);
      min-height: 520px;
      display:flex;
      flex-direction:column;
    }
    .editorWrap iframe{
      width:100%;
      height:100%;
      border:0;
      background:#fff;
    }
    .editorTips{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-top:10px;
    }

    .toast{
      position: fixed;
      bottom: 16px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(17,24,39,.92);
      color: #fff;
      padding: 10px 12px;
      border-radius: 999px;
      box-shadow: 0 12px 26px rgba(0,0,0,.18);
      border: 1px solid rgba(255,255,255,.14);
      font-size: 12px;
      opacity: 0;
      pointer-events: none;
      transition: opacity .18s ease, transform .18s ease;
      z-index: 9999;
      max-width: 92vw;
      text-align:center;
    }
    .toast.show{
      opacity: 1;
      transform: translateX(-50%) translateY(-2px);
    }

    .footer{
      text-align:center;
      color:var(--muted);
      font-size:12px;
      padding:18px 0 6px;
    }

    /* Quick search highlight for internal navigation feel */
    .anchor{
      scroll-margin-top: 86px;
    }
  </style>
</head>

<body>
  <header class="topbar">
    <div class="topbar-inner">
      <div class="brand">
        <div class="logo">JS</div>
        <div>
          <h1>Promises & Async/Await</h1>
          <small>Lead-up to <b>fetch()</b> + SWAPI — with an embedded editor</small>
        </div>
      </div>

      <div class="actions">
        <div class="pill" title="Tip">
          <span>✅</span>
          <span>Copy a snippet → paste into the editor → Run</span>
        </div>
        <button class="btn ghost" id="btnOpenEditor">Open Editor in New Tab</button>
        <button class="btn primary" id="btnScrollEditor">Jump to Editor</button>
      </div>
    </div>
  </header>

  <main>
    <section class="card">
      <div class="card-head">
        <div class="kicker">What you will learn</div>
        <h2>From “normal tasks” → Promises → async/await → fetch + SWAPI</h2>
        <div class="toc">
          <a href="#sync-vs-async">Sync vs Async</a>
          <a href="#promise-basics">Promise Basics</a>
          <a href="#chaining-errors">Chaining & Errors</a>
          <a href="#promise-tools">Promise Tools</a>
          <a href="#async-await">Async/Await</a>
          <a href="#fetch-swapi">Fetch + SWAPI</a>
          <a href="#practice">Practice</a>
          <a href="#editor">Embedded Editor</a>
        </div>
      </div>
      <div class="card-body">
        <div class="note">
          <b>How to use this page:</b> Each code box has a <b>Copy</b> button. Copy → paste into the embedded editor (right side on desktop / below on mobile) → run and observe the output.
        </div>
      </div>
    </section>

    <div class="grid">
      <!-- LESSON COLUMN -->
      <section class="card">
        <div class="card-head">
          <div class="kicker anchor" id="sync-vs-async">Part 1</div>
          <h2>Normal tasks vs async tasks (the core idea)</h2>
        </div>
        <div class="card-body">
          <p class="mini">
            JavaScript runs your code top-to-bottom. But some operations finish <b>later</b> (timers, network, I/O).
            Promises + async/await help you write clean “do this, then do that” logic without messy callbacks.
          </p>

          <div class="split">
            <div>
              <h3>✅ Synchronous (normal) tasks</h3>
              <div class="codeblock">
                <div class="codebar">
                  <div class="title">Demo A — Normal flow</div>
                  <button class="btn" data-copy="codeA">Copy</button>
                </div>
<pre id="codeA">console.log("A: Start");

function normalTask() {
  console.log("B: Normal task running");
}

normalTask();

console.log("C: End");</pre>
              </div>
            </div>

            <div>
              <h3>⏳ Asynchronous task (timer)</h3>
              <div class="codeblock">
                <div class="codebar">
                  <div class="title">Demo B — Async without waiting</div>
                  <button class="btn" data-copy="codeB">Copy</button>
                </div>
<pre id="codeB">console.log("A: Start");

setTimeout(() => {
  console.log("B: Timer finished (async)");
}, 1500);

console.log("C: End (runs before timer)");</pre>
              </div>
            </div>
          </div>

          <div class="note">
            <b>Key rule:</b> async work starts, JS continues.  
            To “wait nicely”, we use a <b>Promise</b> (then) or <b>await</b>.
          </div>
        </div>
      </section>

      <!-- EDITOR COLUMN -->
      <section class="card anchor" id="editor">
        <div class="card-head">
          <div class="kicker">Embedded JavaScript Editor</div>
          <h2>Programmer’s Picnic Editor (iframe)</h2>
        </div>
        <div class="card-body editorWrap">
          <iframe
            id="ppEditor"
            title="Programmer's Picnic JavaScript Editor"
            src="https://programmer-s-picnic.github.io/lesson-viewer/java-script/editor/"
            loading="lazy"
            referrerpolicy="no-referrer"
            allow="clipboard-read; clipboard-write; fullscreen"
          ></iframe>

          <div class="editorTips">
            <div class="pill">Tip: Use <b>Console</b> output to observe order</div>
            <div class="pill">Try changing delays: 100ms, 1000ms, 2000ms</div>
          </div>
        </div>
      </section>

      <section class="card">
        <div class="card-head">
          <div class="kicker anchor" id="promise-basics">Part 2</div>
          <h2>Promise basics: pending → fulfilled/rejected</h2>
        </div>
        <div class="card-body">
          <p class="mini">
            A <b>Promise</b> is an object representing a result that you’ll get in the future.
            It has three states: <b>pending</b>, <b>fulfilled</b> (success), <b>rejected</b> (error).
          </p>

          <div class="codeblock">
            <div class="codebar">
              <div class="title">Demo C — Creating a Promise</div>
              <button class="btn" data-copy="codeC">Copy</button>
            </div>
<pre id="codeC">const p = new Promise((resolve, reject) => {
  console.log("1) Promise started (pending)");

  setTimeout(() => {
    const ok = Math.random() &gt; 0.3;

    if (ok) {
      resolve("✅ Success value");
    } else {
      reject(new Error("❌ Something failed"));
    }
  }, 1200);
});

p.then(value =&gt; {
  console.log("2) then:", value);
})
.catch(err =&gt; {
  console.log("3) catch:", err.message);
})
.finally(() =&gt; {
  console.log("4) finally: always runs");
});</pre>
          </div>

          <div class="note">
            <b>Remember:</b> Once a promise is fulfilled or rejected, it’s <b>settled</b> and can’t change again.
          </div>
        </div>
      </section>

      <section class="card">
        <div class="card-head">
          <div class="kicker anchor" id="chaining-errors">Part 3</div>
          <h2>Chaining + errors: “return” is everything</h2>
        </div>
        <div class="card-body">
          <p class="mini">
            In a chain, each <code>.then()</code> receives the previous result. If you return a value, the next then gets it.
            If you return a Promise, the chain waits for it.
          </p>

          <div class="codeblock">
            <div class="codebar">
              <div class="title">Demo D — Chaining transformations</div>
              <button class="btn" data-copy="codeD">Copy</button>
            </div>
<pre id="codeD">Promise.resolve(5)
  .then(x =&gt; {
    console.log("Step1 got:", x);
    return x * 2;
  })
  .then(x =&gt; {
    console.log("Step2 got:", x);
    return new Promise(resolve =&gt; setTimeout(() =&gt; resolve(x + 1), 800));
  })
  .then(x =&gt; {
    console.log("Step3 got:", x);
    return x;
  })
  .catch(err =&gt; console.error("Error:", err));</pre>
          </div>

          <div class="codeblock">
            <div class="codebar">
              <div class="title">Demo E — Errors: throw → catch</div>
              <button class="btn" data-copy="codeE">Copy</button>
            </div>
<pre id="codeE">Promise.resolve("ok")
  .then(() =&gt; {
    console.log("Before throw");
    throw new Error("Boom!");
  })
  .then(() =&gt; {
    console.log("This will not run");
  })
  .catch(err =&gt; {
    console.log("Caught:", err.message);
    return "Recovered value";
  })
  .then(v =&gt; {
    console.log("After recovery:", v);
  });</pre>
          </div>

          <div class="note">
            <b>Most common bug:</b> forgetting <b>return</b> inside <code>.then()</code>.  
            If you don’t return the Promise/value, the next step gets <code>undefined</code>.
          </div>
        </div>
      </section>

      <section class="card">
        <div class="card-head">
          <div class="kicker anchor" id="promise-tools">Part 4</div>
          <h2>Promise utilities: all, allSettled, race, any</h2>
        </div>
        <div class="card-body">
          <p class="mini">
            These helpers are essential for handling multiple async operations cleanly.
          </p>

          <div class="codeblock">
            <div class="codebar">
              <div class="title">Demo F — Promise.all (fail-fast)</div>
              <button class="btn" data-copy="codeF">Copy</button>
            </div>
<pre id="codeF">function delayValue(ms, value, shouldFail=false){
  return new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
      if(shouldFail) reject(new Error("Failed: " + value));
      else resolve(value);
    }, ms);
  });
}

Promise.all([
  delayValue(600, "A"),
  delayValue(900, "B"),
  delayValue(700, "C")
])
.then(values =&gt; console.log("all values:", values))
.catch(err =&gt; console.log("all failed because:", err.message));</pre>
          </div>

          <div class="codeblock">
            <div class="codebar">
              <div class="title">Demo G — Promise.allSettled (always waits)</div>
              <button class="btn" data-copy="codeG">Copy</button>
            </div>
<pre id="codeG">function delayValue(ms, value, shouldFail=false){
  return new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
      if(shouldFail) reject(new Error("Failed: " + value));
      else resolve(value);
    }, ms);
  });
}

Promise.allSettled([
  delayValue(400, "OK-1"),
  delayValue(700, "BAD-2", true),
  delayValue(500, "OK-3")
])
.then(report =&gt; console.log(report));</pre>
          </div>

          <div class="note">
            Use <b>all</b> when you need everything (and want to fail early).  
            Use <b>allSettled</b> when you need a full report (success + failures).
          </div>
        </div>
      </section>

      <section class="card">
        <div class="card-head">
          <div class="kicker anchor" id="async-await">Part 5</div>
          <h2>Async/await: Promises with clean syntax</h2>
        </div>
        <div class="card-body">
          <p class="mini">
            <code>async</code> makes a function return a Promise.  
            <code>await</code> pauses <b>only that async function</b> until the Promise settles.
          </p>

          <div class="codeblock">
            <div class="codebar">
              <div class="title">Demo H — async without await (no waiting)</div>
              <button class="btn" data-copy="codeH">Copy</button>
            </div>
<pre id="codeH">console.log("A: start");

async function demo(){
  setTimeout(() =&gt; console.log("B: inside async (but not awaited)"), 1000);
}

demo();

console.log("C: end");</pre>
          </div>

          <div class="codeblock">
            <div class="codebar">
              <div class="title">Demo I — async + await (real pause inside the function)</div>
              <button class="btn" data-copy="codeI">Copy</button>
            </div>
<pre id="codeI">function delay(ms){
  return new Promise(resolve =&gt; setTimeout(resolve, ms));
}

console.log("A: start");

async function demo(){
  console.log("B: before await");
  await delay(1200);
  console.log("C: after await");
}

demo();
console.log("D: end (runs while demo is waiting)");</pre>
          </div>

          <div class="codeblock">
            <div class="codebar">
              <div class="title">Demo J — try/catch with await</div>
              <button class="btn" data-copy="codeJ">Copy</button>
            </div>
<pre id="codeJ">function mayFail(){
  return new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
      Math.random() &gt; 0.5 ? resolve("OK ✅") : reject(new Error("Random fail ❌"));
    }, 800);
  });
}

async function run(){
  try{
    const v = await mayFail();
    console.log("Success:", v);
  }catch(err){
    console.log("Caught:", err.message);
  }
}
run();</pre>
          </div>

          <div class="note">
            <b>Rule:</b> If you can write it as a chain, you can write it as <code>await</code>.  
            Many learners find async/await easier to read and debug.
          </div>
        </div>
      </section>

      <section class="card">
        <div class="card-head">
          <div class="kicker anchor" id="fetch-swapi">Part 6</div>
          <h2>fetch() + SWAPI: Promises in the real world</h2>
        </div>
        <div class="card-body">
          <p class="mini">
            <code>fetch(url)</code> returns a Promise of a <b>Response</b>.  
            Important: fetch rejects mostly on <b>network errors</b>. For 404/500, you must check <code>res.ok</code>.
          </p>

          <div class="codeblock">
            <div class="codebar">
              <div class="title">Demo K — fetch + then + json (Promise style)</div>
              <button class="btn" data-copy="codeK">Copy</button>
            </div>
<pre id="codeK">fetch("https://swapi.py4e.com/api/people/1/")
  .then(res =&gt; {
    if(!res.ok) throw new Error("HTTP " + res.status);
    return res.json(); // returns a Promise
  })
  .then(person =&gt; {
    console.log("Name:", person.name);
    console.log("Homeworld URL:", person.homeworld);
  })
  .catch(err =&gt; console.error("Fetch error:", err.message));</pre>
          </div>

          <div class="codeblock">
            <div class="codebar">
              <div class="title">Demo L — fetch + await (recommended)</div>
              <button class="btn" data-copy="codeL">Copy</button>
            </div>
<pre id="codeL">async function fetchJSON(url){
  const res = await fetch(url);
  if(!res.ok) throw new Error("HTTP " + res.status + " for " + url);
  return res.json();
}

async function run(){
  try{
    const person = await fetchJSON("https://swapi.py4e.com/api/people/1/");
    const world  = await fetchJSON(person.homeworld);
    console.log(person.name, "is from", world.name);
  }catch(err){
    console.error("Error:", err.message);
  }
}

run();</pre>
          </div>

          <div class="codeblock">
            <div class="codebar">
              <div class="title">Demo M — SWAPI search</div>
              <button class="btn" data-copy="codeM">Copy</button>
            </div>
<pre id="codeM">async function searchPeople(query){
  const url = "https://swapi.py4e.com/api/people/?search=" + encodeURIComponent(query);
  const res = await fetch(url);
  if(!res.ok) throw new Error("HTTP " + res.status);
  const data = await res.json();
  console.log("Found:", data.count);
  data.results.forEach(p =&gt; console.log("-", p.name));
}

searchPeople("skywalker");</pre>
          </div>

          <div class="note">
            <b>Practice tip:</b> Change person id: <code>/people/1/</code> → <code>/people/2/</code>, <code>/people/3/</code>…  
            Try an invalid id: <code>/people/9999/</code> to see HTTP error handling.
          </div>
        </div>
      </section>

      <section class="card">
        <div class="card-head">
          <div class="kicker anchor" id="practice">Part 7</div>
          <h2>Practice tasks (for students)</h2>
        </div>
        <div class="card-body">
          <ol class="mini">
            <li>
              Make a <code>delay(ms)</code> function that returns a Promise. Use it to print:
              <b>1…2…3…GO!</b> with 1 second gap between each.
            </li>
            <li>
              Use <code>Promise.all</code> to fetch 3 people in parallel:
              <code>/people/1/</code>, <code>/people/2/</code>, <code>/people/3/</code>.
            </li>
            <li>
              Write <code>fetchJSON(url)</code> and reuse it everywhere. (You already have it in Demo L.)
            </li>
            <li>
              Take a person and fetch their <code>homeworld</code> and then fetch the world’s <code>residents</code> (first 3).
            </li>
          </ol>

          <div class="codeblock">
            <div class="codebar">
              <div class="title">Starter — 1…2…3…GO! using await</div>
              <button class="btn" data-copy="codeP">Copy</button>
            </div>
<pre id="codeP">function delay(ms){
  return new Promise(resolve =&gt; setTimeout(resolve, ms));
}

async function countdown(){
  console.log("1");
  await delay(1000);
  console.log("2");
  await delay(1000);
  console.log("3");
  await delay(1000);
  console.log("GO!");
}

countdown();</pre>
          </div>
        </div>
      </section>
    </div>

    <div class="footer">
      Built for your lessons: Promises → Async/Await → fetch + SWAPI • Light Saffron Theme
    </div>
  </main>

  <div class="toast" id="toast">Copied!</div>

  <script>
    (function(){
      const toast = document.getElementById("toast");

      function showToast(msg){
        toast.textContent = msg || "Copied!";
        toast.classList.add("show");
        setTimeout(() => toast.classList.remove("show"), 900);
      }

      async function copyText(text){
        // Prefer modern clipboard API; fallback to execCommand.
        try{
          await navigator.clipboard.writeText(text);
          showToast("Copied snippet ✅");
          return true;
        }catch(e){
          try{
            const ta = document.createElement("textarea");
            ta.value = text;
            ta.style.position = "fixed";
            ta.style.opacity = "0";
            document.body.appendChild(ta);
            ta.select();
            document.execCommand("copy");
            document.body.removeChild(ta);
            showToast("Copied snippet ✅");
            return true;
          }catch(err){
            showToast("Copy failed — select & copy manually");
            return false;
          }
        }
      }

      document.addEventListener("click", async (e) => {
        const btn = e.target.closest("[data-copy]");
        if(!btn) return;

        const id = btn.getAttribute("data-copy");
        const pre = document.getElementById(id);
        if(!pre) return;

        await copyText(pre.innerText);
      });

      document.getElementById("btnScrollEditor").addEventListener("click", () => {
        document.getElementById("editor").scrollIntoView({behavior:"smooth", block:"start"});
      });

      document.getElementById("btnOpenEditor").addEventListener("click", () => {
        window.open("https://programmer-s-picnic.github.io/lesson-viewer/java-script/editor/", "_blank", "noopener,noreferrer");
      });

      // Optional: deep-link to sections if user arrives with #hash
      if(location.hash){
        const el = document.querySelector(location.hash);
        if(el) setTimeout(() => el.scrollIntoView({behavior:"smooth"}), 250);
      }
    })();
  </script>
</body>
</html>
