<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Day 3 ‚Äì Arithmetic Operators | Python Starter Club</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta
      name="description"
      content="Day 3 of Python Starter Club by Programmer‚Äôs Picnic. Learn arithmetic operators with a Pyodide editor and a step-by-step expression evaluator by precedence."
    />
    <meta name="author" content="Champak Roy" />

    <style>
      :root {
        --bg: #fffaf2;
        --card: #ffffff;
        --ink: #1f2937;
        --muted: #6b7280;
        --brand: #d97706;
        --brand2: #f59e0b;
        --border: #e5e7eb;
        --shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        --r: 16px;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial,
          sans-serif;
        background: var(--bg);
        color: var(--ink);
        line-height: 1.8;
      }
      .container {
        max-width: 980px;
        margin: auto;
        padding: 20px;
      }
      h1,
      h2,
      h3 {
        color: #92400e;
        margin: 0 0 10px;
      }
      p {
        margin: 10px 0;
      }
      .hero {
        background: linear-gradient(135deg, #fff4dc, #ffe8b5);
        padding: 22px;
        border-radius: var(--r);
        box-shadow: var(--shadow);
        margin-bottom: 24px;
      }
      .hero h1 {
        font-size: 28px;
      }
      .hero .sub {
        color: #7c2d12;
        font-weight: 600;
        margin-top: 6px;
      }
      .grid {
        display: grid;
        gap: 16px;
      }
      @media (min-width: 920px) {
        .grid-2 {
          grid-template-columns: 1.05fr 0.95fr;
        }
      }
      .card {
        background: var(--card);
        border: 1px solid var(--border);
        border-radius: var(--r);
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.06);
        padding: 18px;
      }
      .comic img {
        width: 100%;
        border-radius: 14px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
      }
      pre {
        background: #111827;
        color: #f9fafb;
        padding: 14px;
        border-radius: 12px;
        overflow: auto;
        margin: 12px 0;
      }
      code {
        background: #f3f4f6;
        padding: 3px 6px;
        border-radius: 6px;
        font-family: Consolas, ui-monospace, Menlo, monospace;
        font-size: 14px;
      }
      .row {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        align-items: center;
      }
      .btn {
        border: none;
        border-radius: 12px;
        padding: 10px 12px;
        cursor: pointer;
        font-weight: 650;
        background: linear-gradient(145deg, var(--brand), var(--brand2));
        color: white;
        box-shadow: 0 8px 18px rgba(217, 119, 6, 0.25);
      }
      .btn.secondary {
        background: #f3f4f6;
        color: #111827;
        box-shadow: none;
        border: 1px solid var(--border);
      }
      .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      input[type="text"],
      textarea {
        width: 100%;
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 10px 12px;
        font-size: 15px;
        outline: none;
        background: #fff;
      }
      textarea {
        min-height: 170px;
        font-family: Consolas, ui-monospace, Menlo, monospace;
      }
      .muted {
        color: var(--muted);
        font-size: 14px;
      }
      .pill {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 6px 10px;
        border: 1px solid var(--border);
        border-radius: 999px;
        background: #fff7ed;
        color: #7c2d12;
        font-size: 13px;
        font-weight: 650;
      }
      .exprBox {
        background: #0b1220;
        color: #f9fafb;
        border-radius: 12px;
        padding: 14px;
        overflow: auto;
        font-family: Consolas, ui-monospace, Menlo, monospace;
        font-size: 16px;
        line-height: 1.6;
        border: 1px solid rgba(255, 255, 255, 0.08);
      }
      .hl {
        background: rgba(245, 158, 11, 0.22);
        border: 1px solid rgba(245, 158, 11, 0.45);
        border-radius: 8px;
        padding: 0 4px;
      }
      .task {
        background: #fff7ed;
        border-left: 5px solid var(--brand2);
        padding: 14px;
        border-radius: 12px;
        margin-top: 10px;
      }
      .footer {
        text-align: center;
        margin: 30px 0 10px;
        font-size: 14px;
        color: #555;
      }
      .brand {
        font-weight: 700;
        color: #92400e;
      }
      .mini {
        font-size: 12px;
        color: #9ca3af;
        margin-left: auto;
      }
      .status {
        font-size: 13px;
        padding: 8px 10px;
        border-radius: 12px;
        border: 1px dashed var(--border);
        background: #fff;
      }
      .kbd {
        font-family: ui-monospace, Menlo, Consolas, monospace;
        background: #f3f4f6;
        border: 1px solid var(--border);
        padding: 2px 6px;
        border-radius: 8px;
        font-size: 12px;
      }
      .slider {
        width: 160px;
      }
    </style>
  </head>

  <body>
    <div class="container">
      <div class="hero">
        <h1>Day 3 ‚Äî Arithmetic Operators (Calculations)</h1>
        <div class="sub">
          Python Starter Club ‚Ä¢ Programmer‚Äôs Picnic ‚Ä¢ Champak Roy
        </div>
        <p class="muted">
          Today you‚Äôll learn operators, input-based calculations, and you‚Äôll
          also use an interactive expression evaluator + Python editor.
        </p>
      </div>

      <div class="card comic">
        <h2>üé® Day 3 Comic</h2>
        <p class="muted">
          
        </p>
        <img src="0.png" alt="Day 3 Arithmetic Operators Comic" />
      </div>

      <div class="grid grid-2" style="margin-top: 16px">
        <!-- LEFT: Lesson + examples -->
        <div class="card">
          <div class="row">
            <span class="pill">Lesson</span>
            <span class="mini">Type everything yourself</span>
          </div>

          <h2 style="margin-top: 10px">‚ûï‚ûñ‚úñ‚ûó Operators</h2>
          <pre>
a = 10
b = 5

print(a + b)  # addition
print(a - b)  # subtraction
print(a * b)  # multiplication
print(a / b)  # division (float)</pre
          >

          <h3>‚≠ê Special operators</h3>
          <pre>
print(10 // 3)   # floor division -> 3
print(10 % 3)    # remainder -> 1
print(2 ** 3)    # power -> 8</pre
          >

          <h3>‚å®Ô∏è Input + int()</h3>
          <pre>
a = int(input("Enter first number: "))
b = int(input("Enter second number: "))

print(f"Addition = {a + b}")
print(f"Subtraction = {a - b}")
print(f"Multiplication = {a * b}")</pre
          >

          <h3>üß† Order of operations</h3>
          <pre>
print(10 + 2 * 3)     # 16
print((10 + 2) * 3)   # 36</pre
          >

          <div class="task">
            <b>üìù Day 3 Task</b>
            <p style="margin: 6px 0 0">
              Take two numbers from user and print Addition, Subtraction,
              Multiplication using <code>f""</code>.
            </p>
          </div>
        </div>

        <!-- RIGHT: Interactive precedence evaluator -->
        <div class="card">
          <div class="row">
            <span class="pill">Interactive</span>
            <span class="mini">Priority step-by-step</span>
          </div>

          <h2 style="margin-top: 10px">üßÆ Expression Evaluator</h2>
          <p class="muted">
            Type an expression like:
            <code>10 + 2 * 3</code>, <code>(10 + 2) * 3</code>,
            <code>2**3 + 10//3</code>
          </p>

          <input
            id="exprInput"
            type="text"
            placeholder="e.g. 10 + 2 * 3"
            value="10 + 2 * 3"
          />

          <div class="row" style="margin-top: 10px">
            <button class="btn" id="btnBuild">Build Steps</button>
            <button class="btn secondary" id="btnPrev" disabled>Prev</button>
            <button class="btn secondary" id="btnNext" disabled>Next</button>
            <button class="btn secondary" id="btnPlay" disabled>Play</button>
            <button class="btn secondary" id="btnReset" disabled>Reset</button>
          </div>

          <div class="row" style="margin-top: 10px">
            <div class="status" id="stepStatus">
              No steps yet. Click <b>Build Steps</b>.
            </div>
            <div class="row" style="margin-left: auto">
              <span class="muted">Speed</span>
              <input
                class="slider"
                id="speed"
                type="range"
                min="200"
                max="1600"
                value="700"
              />
            </div>
          </div>

          <div style="margin-top: 12px">
            <div class="exprBox" id="exprView">‚Äî</div>
            <div class="muted" style="margin-top: 8px">
              Tip: Use <span class="kbd">**</span>, <span class="kbd">*</span>,
              <span class="kbd">/</span>, <span class="kbd">//</span>,
              <span class="kbd">%</span>, <span class="kbd">+</span>,
              <span class="kbd">-</span>. No variables here ‚Äî numbers only.
            </div>
          </div>
        </div>
      </div>

      <!-- Pyodide editor -->
      <div class="card" style="margin-top: 16px">
        <div class="row">
          <span class="pill">Pyodide</span>
          <span class="mini">Run Python in browser</span>
        </div>

        <h2 style="margin-top: 10px">üêç Python Editor (Run)</h2>
        <p class="muted">
          This runs Python directly in the page using Pyodide. First run may
          take a few seconds.
        </p>

        <textarea id="pyCode">
# Day 3 practice
a = int(input("Enter first number: "))
b = int(input("Enter second number: "))

print(f"Addition = {a + b}")
print(f"Subtraction = {a - b}")
print(f"Multiplication = {a * b}")</textarea
        >

        <div class="row" style="margin-top: 10px">
          <button class="btn" id="btnRunPy">Run Python</button>
          <button class="btn secondary" id="btnClearOut">Clear Output</button>
          <span class="muted" id="pyStatus">Pyodide not loaded yet.</span>
        </div>

        <pre id="pyOut" aria-live="polite">Output will appear here‚Ä¶</pre>
      </div>

      <div class="footer">
        <span class="brand">Programmer‚Äôs Picnic</span> ‚Ä¢ Champak Roy<br />
        Calm learning. Strong foundations.
      </div>
    </div>

    <!-- Pyodide -->
    <script src="https://cdn.jsdelivr.net/pyodide/v0.26.2/full/pyodide.js"></script>

    <script>
      /* =========================================================
   Expression Evaluator (Step-by-step by precedence)
   Supports: + - * / // % ** and parentheses
   Notes:
   - Numbers only (ints/floats)
   - Left-to-right within same precedence level
   ========================================================= */

      (function () {
        "use strict";

        // ---------- Tokenizer ----------
        function tokenize(s) {
          const src = s.replace(/\s+/g, "");
          if (!src) throw new Error("Empty expression.");
          const tokens = [];
          let i = 0;

          const isDigit = (c) => /[0-9]/.test(c);
          const isOpChar = (c) => "+-*/()%".includes(c) || c === ".";

          while (i < src.length) {
            const c = src[i];

            // number (int/float)
            if (
              isDigit(c) ||
              (c === "." && i + 1 < src.length && isDigit(src[i + 1]))
            ) {
              let j = i,
                dot = 0;
              while (j < src.length && (isDigit(src[j]) || src[j] === ".")) {
                if (src[j] === ".") dot++;
                if (dot > 1)
                  throw new Error(
                    "Invalid number format near: " + src.slice(i, j + 1)
                  );
                j++;
              }
              tokens.push({ type: "num", value: parseFloat(src.slice(i, j)) });
              i = j;
              continue;
            }

            // parentheses
            if (c === "(" || c === ")") {
              tokens.push({ type: "par", value: c });
              i++;
              continue;
            }

            // operators: **, //, +, -, *, /, %
            // check 2-char ops first
            const two = src.slice(i, i + 2);
            if (two === "**" || two === "//") {
              tokens.push({ type: "op", value: two });
              i += 2;
              continue;
            }
            if (["+", "-", "*", "/", "%"].includes(c)) {
              tokens.push({ type: "op", value: c });
              i++;
              continue;
            }

            throw new Error("Invalid character: " + c);
          }

          return tokens;
        }

        // ---------- Shunting Yard to RPN ----------
        const PREC = {
          "**": 4,
          "*": 3,
          "/": 3,
          "//": 3,
          "%": 3,
          "+": 2,
          "-": 2,
        };
        const RIGHT_ASSOC = { "**": true };

        function toRPN(tokens) {
          const out = [];
          const stack = [];

          for (const t of tokens) {
            if (t.type === "num") out.push(t);
            else if (t.type === "op") {
              while (stack.length) {
                const top = stack[stack.length - 1];
                if (top.type !== "op") break;
                const pTop = PREC[top.value],
                  pCur = PREC[t.value];
                if (pTop > pCur || (pTop === pCur && !RIGHT_ASSOC[t.value])) {
                  out.push(stack.pop());
                } else break;
              }
              stack.push(t);
            } else if (t.type === "par" && t.value === "(") {
              stack.push(t);
            } else if (t.type === "par" && t.value === ")") {
              while (
                stack.length &&
                !(
                  stack[stack.length - 1].type === "par" &&
                  stack[stack.length - 1].value === "("
                )
              ) {
                out.push(stack.pop());
              }
              if (!stack.length) throw new Error("Mismatched parentheses.");
              stack.pop(); // remove "("
            }
          }

          while (stack.length) {
            const x = stack.pop();
            if (x.type === "par") throw new Error("Mismatched parentheses.");
            out.push(x);
          }
          return out;
        }

        // ---------- Build AST from RPN ----------
        function astFromRPN(rpn) {
          const st = [];
          for (const t of rpn) {
            if (t.type === "num") st.push({ kind: "num", value: t.value });
            else if (t.type === "op") {
              // binary ops only for our scope
              const b = st.pop();
              const a = st.pop();
              if (!a || !b) throw new Error("Invalid expression.");
              st.push({ kind: "bin", op: t.value, left: a, right: b });
            } else throw new Error("Unexpected token.");
          }
          if (st.length !== 1) throw new Error("Invalid expression.");
          return st[0];
        }

        // ---------- Evaluate one node ----------
        function evalOp(op, a, b) {
          if (op === "+") return a + b;
          if (op === "-") return a - b;
          if (op === "*") return a * b;
          if (op === "/") return a / b;
          if (op === "//") return Math.floor(a / b);
          if (op === "%") return a % b;
          if (op === "**") return a ** b;
          throw new Error("Unknown operator: " + op);
        }

        // ---------- Stringify AST with minimal parentheses (but safe) ----------
        function strAst(node) {
          if (node.kind === "num") {
            // show integers cleanly
            const v = node.value;
            if (Number.isFinite(v) && Math.abs(v - Math.round(v)) < 1e-12)
              return String(Math.round(v));
            return String(v);
          }
          const op = node.op;
          const L = node.left,
            R = node.right;
          const sL = L.kind === "bin" ? "(" + strAst(L) + ")" : strAst(L);
          const sR = R.kind === "bin" ? "(" + strAst(R) + ")" : strAst(R);
          // We keep parentheses around sub-bins to make steps clearer for beginners.
          return `${sL}${op}${sR}`;
        }

        // ---------- Collect evaluation steps (post-order; precedence already encoded in AST) ----------
        // We generate steps by repeatedly replacing the next reducible node (a bin whose children are numbers).
        function clone(node) {
          return JSON.parse(JSON.stringify(node));
        }

        function findNextReduciblePath(node, path = []) {
          // Prefer deeper first => evaluates inner parentheses first naturally.
          if (node.kind === "bin") {
            // Try left subtree
            const leftPath = findNextReduciblePath(
              node.left,
              path.concat(["left"])
            );
            if (leftPath) return leftPath;
            // Try right subtree
            const rightPath = findNextReduciblePath(
              node.right,
              path.concat(["right"])
            );
            if (rightPath) return rightPath;

            // If both children are numbers, reducible now
            if (node.left.kind === "num" && node.right.kind === "num") {
              return path; // path to this node
            }
          }
          return null;
        }

        function getNodeByPath(root, path) {
          let cur = root;
          for (const p of path) cur = cur[p];
          return cur;
        }

        function setNodeByPath(root, path, newNode) {
          if (path.length === 0) {
            // replace root
            return newNode;
          }
          const parentPath = path.slice(0, -1);
          const key = path[path.length - 1];
          const parent = getNodeByPath(root, parentPath);
          parent[key] = newNode;
          return root;
        }

        function buildStepsFromAst(ast) {
          const steps = [];
          let cur = clone(ast);

          // initial display
          steps.push({
            expr: strAst(cur),
            focus: null,
            note: "Start",
          });

          while (true) {
            const path = findNextReduciblePath(cur, []);
            if (!path) break;

            const node = getNodeByPath(cur, path);
            const a = node.left.value,
              b = node.right.value;
            const res = evalOp(node.op, a, b);

            // Build focus expression for UI (highlight the exact sub-expression string)
            const focusStr = strAst(node);
            const before = strAst(cur);

            // Replace this node with number
            cur = setNodeByPath(cur, path, { kind: "num", value: res });
            const after = strAst(cur);

            steps.push({
              expr: after,
              focus: focusStr,
              note: `${focusStr} = ${Number.isFinite(res) ? res : "NaN"}`,
            });

            // Safety: prevent infinite loops
            if (steps.length > 200)
              throw new Error("Too many steps. Expression too complex.");
          }

          // final
          const finalStr = strAst(cur);
          steps.push({
            expr: finalStr,
            focus: null,
            note: "Done",
          });

          // Remove duplicate final if last evaluation already produced final
          // Keep it simple (safe even if duplicated)
          return steps;
        }

        // ---------- Render with highlight ----------
        function renderExpr(expr, focus) {
          if (!expr) return "‚Äî";
          if (!focus) return expr;
          // Highlight first occurrence of focus substring
          const idx = expr.indexOf(focus);
          if (idx < 0) return expr;
          return (
            expr.slice(0, idx) +
            `<span class="hl">${focus}</span>` +
            expr.slice(idx + focus.length)
          );
        }

        // ---------- UI wiring ----------
        const exprInput = document.getElementById("exprInput");
        const btnBuild = document.getElementById("btnBuild");
        const btnPrev = document.getElementById("btnPrev");
        const btnNext = document.getElementById("btnNext");
        const btnPlay = document.getElementById("btnPlay");
        const btnReset = document.getElementById("btnReset");
        const exprView = document.getElementById("exprView");
        const stepStatus = document.getElementById("stepStatus");
        const speed = document.getElementById("speed");

        let steps = [];
        let iStep = 0;
        let timer = null;

        function stopPlay() {
          if (timer) {
            clearInterval(timer);
            timer = null;
          }
          btnPlay.textContent = "Play";
        }

        function setButtons() {
          const has = steps.length > 0;
          btnPrev.disabled = !has || iStep <= 0;
          btnNext.disabled = !has || iStep >= steps.length - 1;
          btnReset.disabled = !has;
          btnPlay.disabled = !has || steps.length <= 1;
        }

        function draw() {
          if (!steps.length) {
            exprView.textContent = "‚Äî";
            stepStatus.innerHTML = "No steps yet. Click <b>Build Steps</b>.";
            setButtons();
            return;
          }
          const s = steps[iStep];
          exprView.innerHTML = renderExpr(s.expr, s.focus);
          stepStatus.textContent = `Step ${iStep + 1}/${steps.length}: ${
            s.note
          }`;
          setButtons();
        }

        btnBuild.addEventListener("click", () => {
          stopPlay();
          try {
            const tokens = tokenize(exprInput.value);
            const rpn = toRPN(tokens);
            const ast = astFromRPN(rpn);
            steps = buildStepsFromAst(ast);

            // Improve focus highlight: use previous expression focus when possible
            // We store focus on each evaluation step as the reducible subexpr from the state before replacement
            // For clarity, rebuild focus as the one computed in that step's note (already fine).

            iStep = 0;
            draw();
          } catch (e) {
            steps = [];
            iStep = 0;
            exprView.textContent = "‚Äî";
            stepStatus.textContent = "Error: " + e.message;
            setButtons();
          }
        });

        btnNext.addEventListener("click", () => {
          stopPlay();
          if (iStep < steps.length - 1) {
            iStep++;
            draw();
          }
        });

        btnPrev.addEventListener("click", () => {
          stopPlay();
          if (iStep > 0) {
            iStep--;
            draw();
          }
        });

        btnReset.addEventListener("click", () => {
          stopPlay();
          iStep = 0;
          draw();
        });

        btnPlay.addEventListener("click", () => {
          if (!steps.length) return;

          if (timer) {
            stopPlay();
            return;
          }

          btnPlay.textContent = "Pause";
          timer = setInterval(() => {
            if (iStep >= steps.length - 1) {
              stopPlay();
              return;
            }
            iStep++;
            draw();
          }, Number(speed.value));
        });

        speed.addEventListener("input", () => {
          if (timer) {
            // restart timer with new speed
            const was = timer;
            stopPlay();
            btnPlay.textContent = "Pause";
            timer = setInterval(() => {
              if (iStep >= steps.length - 1) {
                stopPlay();
                return;
              }
              iStep++;
              draw();
            }, Number(speed.value));
          }
        });

        // initial
        draw();
      })();

      /* =========================================================
   Pyodide Python Runner
   ========================================================= */
      (function () {
        "use strict";

        const btnRun = document.getElementById("btnRunPy");
        const btnClear = document.getElementById("btnClearOut");
        const codeEl = document.getElementById("pyCode");
        const outEl = document.getElementById("pyOut");
        const statusEl = document.getElementById("pyStatus");

        let pyodideReady = null;

        function appendOut(s) {
          outEl.textContent += s;
        }

        function setStatus(s) {
          statusEl.textContent = s;
        }

        async function ensurePyodide() {
          if (pyodideReady) return pyodideReady;
          setStatus("Loading Pyodide...");
          pyodideReady = loadPyodide({
            stdout: (s) => appendOut(s + "\n"),
            stderr: (s) => appendOut(s + "\n"),
          })
            .then(async (py) => {
              // Basic input() support via JS prompt
              py.globals.set("input", (promptText) => {
                const p = promptText ? String(promptText) : "";
                const v = window.prompt(p, "");
                return v === null ? "" : String(v);
              });
              setStatus("Pyodide ready.");
              return py;
            })
            .catch((e) => {
              setStatus("Failed to load Pyodide: " + e.message);
              throw e;
            });
          return pyodideReady;
        }

        btnClear.addEventListener("click", () => {
          outEl.textContent = "";
        });

        btnRun.addEventListener("click", async () => {
          outEl.textContent = "";
          try {
            const py = await ensurePyodide();
            setStatus("Running...");
            await py.runPythonAsync(codeEl.value);
            setStatus("Done.");
          } catch (e) {
            appendOut("\nError: " + e.message + "\n");
            setStatus("Error.");
          }
        });
      })();
    </script>
  </body>
</html>
