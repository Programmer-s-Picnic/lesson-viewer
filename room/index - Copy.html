<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Virtual Board on Classroom Wall</title>
    <style>
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        font-family:
          system-ui,
          -apple-system,
          Segoe UI,
          Roboto,
          Arial,
          sans-serif;
        background: #111827;
        color: #111827;
      }
      .topbar {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        z-index: 50;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        align-items: center;
        padding: 10px;
        background: rgba(255, 255, 255, 0.9);
        backdrop-filter: blur(10px);
        border-bottom: 1px solid rgba(0, 0, 0, 0.08);
      }
      .topbar .group {
        display: flex;
        gap: 8px;
        align-items: center;
        padding-right: 10px;
        margin-right: 10px;
        border-right: 1px dashed rgba(0, 0, 0, 0.15);
      }
      .topbar .group:last-child {
        border-right: none;
        margin-right: 0;
        padding-right: 0;
      }
      button {
        border: 1px solid rgba(0, 0, 0, 0.12);
        background: #fff;
        padding: 8px 10px;
        border-radius: 12px;
        font-weight: 700;
        cursor: pointer;
      }
      button.primary {
        border: none;
        background: linear-gradient(145deg, #ffb020, #ff7a18);
      }
      button.active {
        outline: 2px solid rgba(255, 176, 32, 0.55);
      }
      input[type="range"] {
        width: 120px;
      }
      .stage {
        position: relative;
        width: 100vw;
        height: 100vh;
        overflow: hidden;
      }
      /* background image */
      .bg {
        position: absolute;
        inset: 0;
        background: #000 url("classroom.jpg") center / cover no-repeat;
        filter: none;
        transform: translateZ(0);
      }

      /* Canvas overlay box */
      .boardBox {
        position: absolute;
        /* default placement (you will calibrate and it will save) */
        left: 25%;
        top: 25%;
        width: 50%;
        height: 50%;
        border-radius: 10px;
        border-color: red;
        border-style: none;
        touch-action: none;
      }

      /* The drawing surface */
      canvas {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        display: block;
        border-radius: 10px;
        /* subtle glass effect so you can see where it is */
        background: rgba(255, 255, 255, 0.04);
      }

      /* Calibration UI */
      .calibOutline {
        position: absolute;
        inset: -2px;
        border: 2px dashed rgba(255, 176, 32, 0.95);
        border-radius: 12px;
        pointer-events: none;
        display: none;
      }
      .handle {
        position: absolute;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: #ffb020;
        border: 2px solid #111827;
        box-shadow: 0 10px 18px rgba(0, 0, 0, 0.2);
        display: none;
        touch-action: none;
      }
      .h-nw {
        left: -9px;
        top: -9px;
        cursor: nwse-resize;
      }
      .h-ne {
        right: -9px;
        top: -9px;
        cursor: nesw-resize;
      }
      .h-sw {
        left: -9px;
        bottom: -9px;
        cursor: nesw-resize;
      }
      .h-se {
        right: -9px;
        bottom: -9px;
        cursor: nwse-resize;
      }

      .hint {
        position: fixed;
        right: 10px;
        bottom: 10px;
        z-index: 60;
        background: rgba(255, 255, 255, 0.92);
        border: 1px solid rgba(0, 0, 0, 0.1);
        padding: 10px 12px;
        border-radius: 14px;
        max-width: 360px;
        font-size: 13px;
        color: #374151;
      }
      .kbd {
        font-family:
          ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", monospace;
        background: #111827;
        color: #fff;
        padding: 2px 8px;
        border-radius: 10px;
        font-size: 12px;
      }
      @media (max-width: 560px) {
        input[type="range"] {
          width: 90px;
        }
        .hint {
          max-width: 92vw;
        }
      }
    </style>
  </head>
  <body>
    <div class="topbar" role="toolbar" aria-label="Board tools">
      <div class="group">
        <strong>Virtual Board</strong>
      </div>

      <div class="group">
        <button id="penBtn" class="primary active">‚úçÔ∏è Pen</button>
        <button id="eraserBtn">üßΩ Eraser</button>
      </div>

      <div class="group">
        <label style="font-size: 12px; opacity: 0.7">Color</label>
        <input id="color" type="color" value="#111827" />
        <label style="font-size: 12px; opacity: 0.7">Size</label>
        <input id="size" type="range" min="2" max="30" value="6" />
        <span
          id="sizeVal"
          style="min-width: 24px; font-weight: 800; text-align: right"
          >6</span
        >
      </div>

      <div class="group">
        <button id="clearBtn">üóëÔ∏è Clear</button>
        <button id="saveBtn">üíæ Save PNG</button>
      </div>

      <div class="group">
        <button id="calibBtn">üß≠ Calibrate</button>
        <button id="resetBtn">‚Ü©Ô∏è Reset Position</button>
      </div>
    </div>

    <div class="stage">
      <div class="bg" aria-hidden="true"></div>

      <div id="boardBox" class="boardBox">
        <div id="calibOutline" class="calibOutline"></div>
        <div class="handle h-nw" data-handle="nw"></div>
        <div class="handle h-ne" data-handle="ne"></div>
        <div class="handle h-sw" data-handle="sw"></div>
        <div class="handle h-se" data-handle="se"></div>
        <canvas id="board"></canvas>
      </div>
    </div>

    <div class="hint">
      <div style="font-weight: 800; margin-bottom: 6px">Tip</div>
      <div>
        1) Put your photo as <span class="kbd">classroom.jpg</span><br />
        2) Press <span class="kbd">Calibrate</span> and drag/resize canvas to
        match the whiteboard.<br />
        3) Turn off Calibrate and write.
      </div>
    </div>

    <script>
      (() => {
        const boardBox = document.getElementById("boardBox");
        const canvas = document.getElementById("board");
        const ctx = canvas.getContext("2d");
        const penBtn = document.getElementById("penBtn");
        const eraserBtn = document.getElementById("eraserBtn");
        const colorEl = document.getElementById("color");
        const sizeEl = document.getElementById("size");
        const sizeVal = document.getElementById("sizeVal");
        const clearBtn = document.getElementById("clearBtn");
        const saveBtn = document.getElementById("saveBtn");
        const calibBtn = document.getElementById("calibBtn");
        const resetBtn = document.getElementById("resetBtn");
        const outline = document.getElementById("calibOutline");
        const handles = Array.from(boardBox.querySelectorAll(".handle"));

        let tool = "pen";
        let drawing = false;
        let last = null;

        let calibrate = false;
        let dragMode = null; // 'move' or 'resize'
        let activeHandle = null;
        let startRect = null;
        let startPt = null;

        const LS_KEY = "pp_board_overlay_rect_v1";

        // --- Canvas sizing (keeps crisp lines)
        function fitCanvasToBox() {
          const r = boardBox.getBoundingClientRect();
          const dpr = window.devicePixelRatio || 1;
          canvas.width = Math.max(1, Math.floor(r.width * dpr));
          canvas.height = Math.max(1, Math.floor(r.height * dpr));
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
          ctx.lineCap = "round";
          ctx.lineJoin = "round";
        }

        // --- Drawing
        function setTool(next) {
          tool = next;
          penBtn.classList.toggle("active", tool === "pen");
          eraserBtn.classList.toggle("active", tool === "eraser");
        }

        function getPos(e) {
          const r = canvas.getBoundingClientRect();
          const x = (e.clientX ?? e.touches?.[0]?.clientX) - r.left;
          const y = (e.clientY ?? e.touches?.[0]?.clientY) - r.top;
          return { x, y };
        }

        function stroke(a, b) {
          const size = Number(sizeEl.value);
          ctx.lineWidth = size;

          if (tool === "eraser") {
            ctx.globalCompositeOperation = "destination-out";
            ctx.strokeStyle = "rgba(0,0,0,1)";
          } else {
            ctx.globalCompositeOperation = "source-over";
            ctx.strokeStyle = colorEl.value;
          }
          ctx.beginPath();
          ctx.moveTo(a.x, a.y);
          ctx.lineTo(b.x, b.y);
          ctx.stroke();
        }

        function startDraw(e) {
          if (calibrate) return; // in calibrate mode, drawing disabled
          drawing = true;
          last = getPos(e);
          e.preventDefault();
        }
        function moveDraw(e) {
          if (!drawing || calibrate) return;
          const p = getPos(e);
          stroke(last, p);
          last = p;
          e.preventDefault();
        }
        function endDraw() {
          drawing = false;
          last = null;
        }

        canvas.addEventListener("pointerdown", startDraw);
        canvas.addEventListener("pointermove", moveDraw);
        window.addEventListener("pointerup", endDraw);
        window.addEventListener("pointercancel", endDraw);

        // --- Calibration: save/restore overlay rect as percentages (responsive)
        function getStageRect() {
          return document.querySelector(".stage").getBoundingClientRect();
        }

        function pxToPctRect(pxRect) {
          const s = getStageRect();
          return {
            left: (pxRect.left - s.left) / s.width,
            top: (pxRect.top - s.top) / s.height,
            width: pxRect.width / s.width,
            height: pxRect.height / s.height,
          };
        }

        function pctToStyle(p) {
          boardBox.style.left = p.left * 100 + "%";
          boardBox.style.top = p.top * 100 + "%";
          boardBox.style.width = p.width * 100 + "%";
          boardBox.style.height = p.height * 100 + "%";
          fitCanvasToBox();
        }

        function saveRect() {
          const r = boardBox.getBoundingClientRect();
          const p = pxToPctRect(r);
          localStorage.setItem(LS_KEY, JSON.stringify(p));
        }

        function loadRect() {
          try {
            const raw = localStorage.getItem(LS_KEY);
            if (!raw) return null;
            return JSON.parse(raw);
          } catch (e) {
            return null;
          }
        }

        function setCalibrate(on) {
          calibrate = on;
          calibBtn.classList.toggle("active", calibrate);

          outline.style.display = calibrate ? "block" : "none";
          handles.forEach(
            (h) => (h.style.display = calibrate ? "block" : "none"),
          );

          // In calibrate mode, allow moving/resizing by dragging boardBox
          boardBox.style.cursor = calibrate ? "move" : "default";
        }

        function pointerPoint(e) {
          return { x: e.clientX, y: e.clientY };
        }

        function beginMoveOrResize(e, mode, handle = null) {
          if (!calibrate) return;
          dragMode = mode;
          activeHandle = handle;
          startRect = boardBox.getBoundingClientRect();
          startPt = pointerPoint(e);
          e.preventDefault();
        }

        function applyMove(e) {
          const s = getStageRect();
          const dx = e.clientX - startPt.x;
          const dy = e.clientY - startPt.y;

          // compute new rect
          let left = startRect.left + dx;
          let top = startRect.top + dy;
          // clamp to stage
          left = Math.max(s.left, Math.min(left, s.right - startRect.width));
          top = Math.max(s.top, Math.min(top, s.bottom - startRect.height));

          const p = pxToPctRect({
            left,
            top,
            width: startRect.width,
            height: startRect.height,
          });
          pctToStyle(p);
        }

        function applyResize(e) {
          const s = getStageRect();
          const dx = e.clientX - startPt.x;
          const dy = e.clientY - startPt.y;

          let left = startRect.left;
          let top = startRect.top;
          let width = startRect.width;
          let height = startRect.height;

          const minW = 140,
            minH = 80;

          if (activeHandle === "se") {
            width = Math.max(minW, width + dx);
            height = Math.max(minH, height + dy);
          }
          if (activeHandle === "sw") {
            width = Math.max(minW, width - dx);
            height = Math.max(minH, height + dy);
            left = left + dx;
          }
          if (activeHandle === "ne") {
            width = Math.max(minW, width + dx);
            height = Math.max(minH, height - dy);
            top = top + dy;
          }
          if (activeHandle === "nw") {
            width = Math.max(minW, width - dx);
            height = Math.max(minH, height - dy);
            left = left + dx;
            top = top + dy;
          }

          // clamp within stage
          left = Math.max(s.left, Math.min(left, s.right - width));
          top = Math.max(s.top, Math.min(top, s.bottom - height));

          const p = pxToPctRect({ left, top, width, height });
          pctToStyle(p);
        }

        boardBox.addEventListener("pointerdown", (e) => {
          if (!calibrate) return;
          // If clicked on a handle, ignore here (handle has its own listener)
          if (e.target.classList.contains("handle")) return;
          beginMoveOrResize(e, "move");
        });

        handles.forEach((h) => {
          h.addEventListener("pointerdown", (e) => {
            if (!calibrate) return;
            beginMoveOrResize(e, "resize", h.dataset.handle);
          });
        });

        window.addEventListener("pointermove", (e) => {
          if (!calibrate || !dragMode) return;
          if (dragMode === "move") applyMove(e);
          if (dragMode === "resize") applyResize(e);
        });

        window.addEventListener("pointerup", () => {
          if (!calibrate || !dragMode) return;
          dragMode = null;
          activeHandle = null;
          saveRect(); // save placement after adjustment
        });

        // --- Buttons
        penBtn.addEventListener("click", () => setTool("pen"));
        eraserBtn.addEventListener("click", () => setTool("eraser"));
        sizeEl.addEventListener(
          "input",
          () => (sizeVal.textContent = sizeEl.value),
        );

        clearBtn.addEventListener("click", () => {
          ctx.save();
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.restore();
          fitCanvasToBox();
        });

        saveBtn.onclick = () => {
          const stage = document.querySelector(".stage");
          const stageRect = stage.getBoundingClientRect();

          const output = document.createElement("canvas");
          const dpr = window.devicePixelRatio || 1;
          output.width = stageRect.width * dpr;
          output.height = stageRect.height * dpr;
          const octx = output.getContext("2d");
          octx.scale(dpr, dpr);

          const img = new Image();
          img.onload = function () {
            octx.drawImage(img, 0, 0, stageRect.width, stageRect.height);
            const boardRect = boardBox.getBoundingClientRect();
            const x = boardRect.left - stageRect.left;
            const y = boardRect.top - stageRect.top;
            octx.drawImage(canvas, x, y, boardRect.width, boardRect.height);

            const link = document.createElement("a");
            link.download = "full-classroom-board.png";
            link.href = output.toDataURL("image/png");
            link.click();
          };
          img.src = "classroom.jpg";
        };

        calibBtn.addEventListener("click", () => {
          setCalibrate(!calibrate);
          if (!calibrate) saveRect();
        });

        resetBtn.addEventListener("click", () => {
          localStorage.removeItem(LS_KEY);
          // back to default position
          boardBox.style.left = "38%";
          boardBox.style.top = "56%";
          boardBox.style.width = "46%";
          boardBox.style.height = "28%";
          fitCanvasToBox();
        });

        // --- Init
        setTool("pen");
        sizeVal.textContent = sizeEl.value;

        // Load saved calibration if exists
        const saved = loadRect();
        if (saved) pctToStyle(saved);

        // Resize observer keeps canvas matching the box
        const ro = new ResizeObserver(() => fitCanvasToBox());
        ro.observe(boardBox);

        // First fit
        setTimeout(fitCanvasToBox, 50);

        // Keyboard shortcuts (optional)
        window.addEventListener("keydown", (e) => {
          if (e.key.toLowerCase() === "p") setTool("pen");
          if (e.key.toLowerCase() === "e") setTool("eraser");
        });
      })();
    </script>
  </body>
</html>
