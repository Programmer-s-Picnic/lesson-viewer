<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <!-- Chatbot Gadget with Embedded Programming Dictionary -->

    <div id="crx-chatbot">
      <div id="crx-chat-header">ðŸ¤– Chatbot â€” Programming Dictionary</div>

      <div id="crx-chat-body" aria-live="polite"></div>

      <div id="crx-chat-footer">
        <input
          type="text"
          id="crx-chat-input"
          placeholder="Try: /define recursion or list categories"
        />

        <button id="crx-chat-send">Send</button>
      </div>
    </div>

    <style>
      /* Responsive Chatbot Gadget â€” crx prefix */

      #crx-chatbot {
        width: 320px;

        max-width: 100%;

        height: 420px;

        display: flex;

        flex-direction: column;

        border-radius: 12px;

        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25);

        background: #fff;

        font-family:
          system-ui,
          Segoe UI,
          Roboto,
          Arial;

        overflow: hidden;

        margin: 10px auto; /* centers in page/post */
      }

      #crx-chat-header {
        background: linear-gradient(90deg, #0d6efd, #0069d9);

        color: #fff;

        padding: 10px;

        font-weight: 600;

        text-align: left;
      }

      #crx-chat-body {
        flex: 1;

        padding: 12px;

        overflow: auto;

        font-size: 14px;

        background: linear-gradient(#ffffff, #fafcff);
      }

      #crx-chat-footer {
        display: flex;

        border-top: 1px solid #eee;

        padding: 8px;
      }

      #crx-chat-input {
        flex: 1;

        padding: 8px;

        border: 1px solid #ddd;

        border-radius: 6px;

        font-size: 14px;

        outline: none;
      }

      #crx-chat-send {
        margin-left: 8px;

        padding: 8px 12px;

        background: #0d6efd;

        color: #fff;

        border: none;

        border-radius: 6px;

        cursor: pointer;
      }

      #crx-chat-send:hover {
        background: #0b5ed7;
      }

      .crx-user-msg {
        margin: 8px 0;
        text-align: right;
      }

      .crx-user-msg .bubble {
        display: inline-block;
        padding: 8px 10px;
        background: #e9f5ff;
        border-radius: 10px;
        max-width: 80%;
      }

      .crx-bot-msg {
        margin: 8px 0;
        text-align: left;
      }

      .crx-bot-msg .bubble {
        display: inline-block;
        padding: 8px 10px;
        background: #f1f3f5;
        border-radius: 10px;
        max-width: 100%;
      }

      .crx-term {
        font-weight: 700;
        color: #0645ad;
      }

      .crx-cat {
        font-size: 12px;
        color: #666;
        margin-top: 4px;
      }

      .crx-suggestion {
        display: inline-block;
        margin: 6px 6px 0 0;
        padding: 6px 8px;
        border-radius: 6px;
        background: #eef6ff;
        cursor: pointer;
        font-size: 13px;
      }

      .crx-small {
        font-size: 12px;
        color: #666;
      }

      /* Mobile view: full width */

      @media (max-width: 600px) {
        #crx-chatbot {
          width: 100%;

          height: 400px;

          border-radius: 0;
        }
      }
    </style>

    <script>
      (function () {
        const body = document.getElementById("crx-chat-body");

        const input = document.getElementById("crx-chat-input");

        const send = document.getElementById("crx-chat-send");

        // Embedded programming dictionary

        const dictionary = {
          "Basic Units": {
            Token: "Smallest unit of code.",

            Lexeme: "Characters forming a token.",

            Identifier: "Name for variables/functions.",

            Keyword: "Reserved word in the language.",

            Literal: "Fixed constant value.",

            Operator: "Symbol performing an operation.",
          },

          "Compiler Phases": {
            "Lexical Analysis": "Breaks code into tokens.",

            Parsing: "Checks grammar structure of tokens.",

            Syntax: "Language grammar rules.",

            "Semantic Analysis": "Ensures meaning is correct.",
          },

          "Code Constructs": {
            Expression: "Produces a value from literals/operators.",

            Statement: "A complete instruction in code.",
          },

          "Data Structures in Compilers": {
            "Symbol Table": "Stores identifiers with details.",

            "Abstract Syntax Tree": "Tree form of code structure.",
          },

          "Operator Categories": {
            "Arithmetic Operators": "Math (+, -, *, /, %).",

            "Relational Operators": "Comparisons (==, !=, >, <).",

            "Logical Operators": "Boolean logic (&&, ||, !).",

            "Assignment Operators": "Assign/update values (=, +=, -=).",

            "Bitwise Operators": "Bit-level ops (&, |, ^, <<, >>).",

            "Increment/Decrement Operators": "++ and --.",

            "Ternary Operator": "Shorthand conditional (?:).",
          },

          "Execution Related": {
            Compiler: "Translates code to machine instructions.",

            Interpreter: "Runs code line by line.",

            Runtime: "Environment where program executes.",

            "Virtual Machine": "Software-based execution machine.",

            Bytecode: "Intermediate code (e.g., Java bytecode).",

            "Machine Code": "Binary instructions for CPU.",

            Linker: "Joins object files into executable.",

            Loader: "Loads program into memory.",
          },

          "Memory & Errors": {
            Stack: "Stores function calls & locals.",

            Heap: "Stores dynamically allocated data.",

            Scope: "Region where variable is valid.",

            "Syntax Error": "Grammar mistake in code.",

            "Semantic Error": "Logical meaning mistake.",

            "Runtime Error": "Error during execution.",
          },

          "OOP (Object-Oriented Programming)": {
            Class: "Blueprint for creating objects.",

            Object: "Instance of a class.",

            Attribute: "Data/variable inside a class.",

            Method: "Function inside a class.",

            Constructor: "Special method to initialize objects.",

            Destructor: "Special method to clean up resources.",

            Inheritance: "Reusing properties/methods from another class.",

            Encapsulation: "Hiding data and providing controlled access.",

            Abstraction: "Showing essential features, hiding details.",

            Polymorphism: "Ability of methods/objects to take many forms.",

            Overloading: "Same method name with different parameters.",

            Overriding: "Subclass provides its own method implementation.",

            Interface: "Contract defining methods a class must implement.",

            "Abstract Class":
              "Class that cannot be instantiated, only inherited.",
          },

          "Data Structures & Algorithms (DSA)": {
            Array:
              "Collection of elements stored at contiguous memory locations.",

            "Linked List":
              "Sequence of nodes where each node points to the next.",

            Stack: "LIFO (Last In, First Out) structure, uses push/pop.",

            Queue:
              "FIFO (First In, First Out) structure, uses enqueue/dequeue.",

            Deque: "Double-ended queue, insert/remove at both ends.",

            Tree: "Hierarchical structure with root and child nodes.",

            "Binary Tree": "Tree where each node has max two children.",

            "Binary Search Tree": "Binary tree with ordered nodes.",

            Heap: "Complete binary tree used for priority operations.",

            Graph: "Collection of nodes (vertices) connected by edges.",

            "Hash Table": "Key-value storage using hash functions.",

            Recursion: "Function calling itself to solve subproblems.",

            Iteration: "Repetition using loops.",

            Sorting:
              "Arranging data (Bubble, Selection, Insertion, Quick, Merge, Heap sort).",

            Searching: "Finding elements (Linear Search, Binary Search).",

            "Dynamic Programming":
              "Breaking problems into overlapping subproblems.",

            "Greedy Algorithm":
              "Builds solution step by step, choosing locally optimal options.",

            "Divide and Conquer":
              "Splits problem into smaller parts and solves recursively.",

            "Big O Notation": "Describes algorithmâ€™s time/space complexity.",
          },
        };

        // Helpers

        function addMessage(text, from = "bot", html = false) {
          const wrap = document.createElement("div");

          wrap.className = from === "user" ? "crx-user-msg" : "crx-bot-msg";

          const b = document.createElement("div");

          b.className = "bubble";

          if (html) b.innerHTML = text;
          else b.textContent = text;

          wrap.appendChild(b);
          body.appendChild(wrap);

          body.scrollTop = body.scrollHeight;
        }

        function addBotHtml(html) {
          addMessage(html, "bot", true);
        }

        function normalize(s) {
          return s.trim().toLowerCase();
        }

        // Search dictionary

        function findTerm(term) {
          const t = normalize(term),
            results = [];

          for (const cat in dictionary) {
            for (const key in dictionary[cat]) {
              if (key.toLowerCase() === t)
                results.push({ cat, term: key, def: dictionary[cat][key] });
            }
          }

          if (results.length === 0) {
            for (const cat in dictionary) {
              for (const key in dictionary[cat]) {
                if (key.toLowerCase().includes(t))
                  results.push({ cat, term: key, def: dictionary[cat][key] });
              }
            }
          }

          return results;
        }

        function listCategories() {
          return Object.keys(dictionary);
        }

        function listTerms(catName) {
          const c = Object.keys(dictionary).find(
            (x) => x.toLowerCase() === catName.toLowerCase(),
          );

          return c
            ? Object.keys(dictionary[c]).map((k) => ({
                term: k,
                def: dictionary[c][k],
              }))
            : null;
        }

        function randomTerm() {
          const cats = Object.keys(dictionary);

          const c = cats[Math.floor(Math.random() * cats.length)];

          const terms = Object.keys(dictionary[c]);

          const t = terms[Math.floor(Math.random() * terms.length)];

          return { cat: c, term: t, def: dictionary[c][t] };
        }

        // Handle user input

        function handleUserText(text) {
          const raw = text.trim(),
            low = raw.toLowerCase();

          if (low === "help" || low === "/help") {
            addBotHtml(
              "<div class='crx-small'>Commands:<br>â€¢ /define term<br>â€¢ list categories<br>â€¢ list category<br>â€¢ /random</div>",
            );

            return;
          }

          if (low === "/random" || low === "random") {
            const r = randomTerm();

            addBotHtml(
              `<div><span class='crx-term'>${r.term}</span><div class='crx-cat'>${r.cat}</div><div>${r.def}</div></div>`,
            );

            return;
          }

          if (low === "list categories") {
            const cats = listCategories();

            addBotHtml(`<div class='crx-small'>${cats.join("<br>")}</div>`);

            return;
          }

          if (low.startsWith("list ")) {
            const cat = raw.slice(5);

            const terms = listTerms(cat);

            if (!terms) {
              addMessage("Category not found");
              return;
            }

            addBotHtml(
              `<div><strong>${cat}</strong><br>${terms.map((t) => t.term).join(", ")}</div>`,
            );

            return;
          }

          if (
            low.startsWith("/define ") ||
            low.startsWith("define ") ||
            low.startsWith("what is ")
          ) {
            const term = raw.replace(/^(\/define|define|what is)\s+/i, "");

            const res = findTerm(term);

            if (res.length === 0) {
              addMessage("Not found. Try list categories.");
              return;
            }

            addBotHtml(
              res
                .map(
                  (r) =>
                    `<div><span class='crx-term'>${r.term}</span><div class='crx-cat'>${r.cat}</div><div>${r.def}</div></div>`,
                )
                .join(""),
            );

            return;
          }

          if (low.includes("hello") || low.includes("hi")) {
            addMessage("Hello! Try /define recursion or list categories");

            return;
          }

          const fb = findTerm(raw);

          if (fb.length > 0) {
            addBotHtml(
              fb
                .map(
                  (r) =>
                    `<div><span class='crx-term'>${r.term}</span><div class='crx-cat'>${r.cat}</div><div>${r.def}</div></div>`,
                )
                .join(""),
            );

            return;
          }

          addMessage("Sorry, I couldnâ€™t understand. Type help for commands.");
        }

        // Events

        send.addEventListener("click", () => {
          const text = input.value.trim();

          if (!text) return;

          addMessage(text, "user");

          input.value = "";

          handleUserText(text);
        });

        input.addEventListener("keypress", (e) => {
          if (e.key === "Enter") send.click();
        });

        // Greeting

        addBotHtml(
          "Hello! Ask me about programming terms. Try <code>/define recursion</code> or type <code>list categories</code>.",
        );
      })();
    </script>
  </body>
</html>
