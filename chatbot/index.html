<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <!-- Chatbot Gadget with Embedded Programming Dictionary -->

    <div id="crx-chatbot">
      <div id="crx-chat-header">ü§ñ Chatbot ‚Äî Programming Dictionary</div>

      <div id="crx-chat-body" aria-live="polite"></div>

      <div id="crx-chat-footer">
        <input
          type="text"
          id="crx-chat-input"
          placeholder="Try: /define recursion or list categories"
        />

        <button id="crx-chat-send">Send</button>
      </div>
    </div>

    <style>
      /* (YOUR ORIGINAL CSS ‚Äî UNCHANGED) */
      /* Responsive Chatbot Gadget ‚Äî crx prefix */
      #crx-chatbot {
        width: 320px;
        max-width: 100%;
        height: 420px;
        display: flex;
        flex-direction: column;
        border-radius: 12px;
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25);
        background: #fff;
        font-family:
          system-ui,
          Segoe UI,
          Roboto,
          Arial;
        overflow: hidden;
        margin: 10px auto;
      }
      #crx-chat-header {
        background: linear-gradient(90deg, #0d6efd, #0069d9);
        color: #fff;
        padding: 10px;
        font-weight: 600;
        text-align: left;
      }
      #crx-chat-body {
        flex: 1;
        padding: 12px;
        overflow: auto;
        font-size: 14px;
        background: linear-gradient(#ffffff, #fafcff);
      }
      #crx-chat-footer {
        display: flex;
        border-top: 1px solid #eee;
        padding: 8px;
      }
      #crx-chat-input {
        flex: 1;
        padding: 8px;
        border: 1px solid #ddd;
        border-radius: 6px;
        font-size: 14px;
        outline: none;
      }
      #crx-chat-send {
        margin-left: 8px;
        padding: 8px 12px;
        background: #0d6efd;
        color: #fff;
        border: none;
        border-radius: 6px;
        cursor: pointer;
      }
      #crx-chat-send:hover {
        background: #0b5ed7;
      }
      .crx-user-msg {
        margin: 8px 0;
        text-align: right;
      }
      .crx-user-msg .bubble {
        display: inline-block;
        padding: 8px 10px;
        background: #e9f5ff;
        border-radius: 10px;
        max-width: 80%;
      }
      .crx-bot-msg {
        margin: 8px 0;
        text-align: left;
      }
      .crx-bot-msg .bubble {
        display: inline-block;
        padding: 8px 10px;
        background: #f1f3f5;
        border-radius: 10px;
        max-width: 100%;
      }
      .crx-term {
        font-weight: 700;
        color: #0645ad;
      }
      .crx-cat {
        font-size: 12px;
        color: #666;
        margin-top: 4px;
      }
      .crx-suggestion {
        display: inline-block;
        margin: 6px 6px 0 0;
        padding: 6px 8px;
        border-radius: 6px;
        background: #eef6ff;
        cursor: pointer;
        font-size: 13px;
      }
      .crx-small {
        font-size: 12px;
        color: #666;
      }
      @media (max-width: 600px) {
        #crx-chatbot {
          width: 100%;
          height: 400px;
          border-radius: 0;
        }
      }
    </style>

    <script>
      (function () {
        const body = document.getElementById("crx-chat-body");
        const input = document.getElementById("crx-chat-input");
        const send = document.getElementById("crx-chat-send");

        // JSON will be stored in the same folder as data.json
        const DATA_URL = "./data.json";

        let dictionary = null; // raw JSON
        let searchIndex = []; // flattened index for fast search

        /* -----------------------------
       UI Helpers (unchanged)
    ----------------------------- */
        function addMessage(text, from = "bot", html = false) {
          const wrap = document.createElement("div");
          wrap.className = from === "user" ? "crx-user-msg" : "crx-bot-msg";
          const b = document.createElement("div");
          b.className = "bubble";
          if (html) b.innerHTML = text;
          else b.textContent = text;
          wrap.appendChild(b);
          body.appendChild(wrap);
          body.scrollTop = body.scrollHeight;
        }

        function addBotHtml(html) {
          addMessage(html, "bot", true);
        }

        function normalize(s) {
          return String(s ?? "")
            .trim()
            .toLowerCase();
        }

        function escHtml(s) {
          return String(s ?? "")
            .replaceAll("&", "&amp;")
            .replaceAll("<", "&lt;")
            .replaceAll(">", "&gt;")
            .replaceAll('"', "&quot;")
            .replaceAll("'", "&#039;");
        }

        /* -----------------------------
       Load JSON
    ----------------------------- */
        async function loadDictionary() {
          try {
            addMessage("Loading dictionary...", "bot");
            const res = await fetch(DATA_URL, { cache: "no-store" });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            dictionary = await res.json();
            searchIndex = buildSearchIndex(dictionary);

            addBotHtml(
              "‚úÖ Dictionary loaded. Try <code>/define recursion</code>, <code>/search stack</code>, or <code>list categories</code>.",
            );
          } catch (err) {
            addBotHtml(
              `<div>
            <strong>‚ùå Could not load</strong> <code>${escHtml(DATA_URL)}</code><br>
            <span class="crx-small">Tip: If you are opening the HTML as a file (file://), fetch may be blocked. Use a local server or GitHub Pages.</span>
           </div>`,
            );
          }
        }

        /* -----------------------------
       Deep Search Index
       - indexes EVERY key + value in the JSON (nested objects/arrays)
       - each entry becomes: { path, term, def, blob }
    ----------------------------- */
        function buildSearchIndex(json) {
          const out = [];

          function walk(node, pathParts) {
            if (node === null || node === undefined) return;

            // arrays
            if (Array.isArray(node)) {
              node.forEach((item, i) =>
                walk(item, pathParts.concat([String(i)])),
              );
              return;
            }

            // objects
            if (typeof node === "object") {
              for (const k of Object.keys(node)) {
                const v = node[k];
                const nextPath = pathParts.concat([k]);

                // if v is a primitive, treat k as term and v as def
                if (v === null || v === undefined) {
                  out.push(makeEntry(nextPath, k, ""));
                } else if (
                  typeof v === "string" ||
                  typeof v === "number" ||
                  typeof v === "boolean"
                ) {
                  out.push(makeEntry(nextPath, k, String(v)));
                } else {
                  // still index the key itself as searchable even if nested
                  out.push(makeEntry(nextPath, k, ""));
                  walk(v, nextPath);
                }
              }
              return;
            }

            // primitive leaf without key (rare): index by path end
            const term = pathParts[pathParts.length - 1] || "value";
            out.push(makeEntry(pathParts, term, String(node)));
          }

          function makeEntry(pathParts, term, def) {
            const path = pathParts.join(" ‚Ä∫ ");
            const blob = normalize([path, term, def].join(" "));
            return {
              path,
              term: String(term),
              def: String(def ?? ""),
              blob,
            };
          }

          walk(json, []);
          return out;
        }

        /* -----------------------------
       Search everywhere (ranked)
       ranking:
         - exact term match highest
         - startsWith term
         - includes term
         - includes in definition/path
    ----------------------------- */
        function searchEverywhere(query, limit = 8) {
          const q = normalize(query);
          if (!q) return [];

          const scored = [];

          for (const item of searchIndex) {
            const termN = normalize(item.term);
            const defN = normalize(item.def);
            const pathN = normalize(item.path);

            let score = 0;

            if (termN === q) score += 1000;
            if (termN.startsWith(q)) score += 250;
            if (termN.includes(q)) score += 120;

            if (defN.includes(q)) score += 90;
            if (pathN.includes(q)) score += 40;

            // also allow matching anywhere in blob
            if (score === 0 && item.blob.includes(q)) score += 20;

            if (score > 0) scored.push({ score, item });
          }

          scored.sort((a, b) => b.score - a.score);

          // de-dup by (path + term + def)
          const seen = new Set();
          const results = [];
          for (const s of scored) {
            const key = s.item.path + "|" + s.item.term + "|" + s.item.def;
            if (seen.has(key)) continue;
            seen.add(key);
            results.push(s.item);
            if (results.length >= limit) break;
          }
          return results;
        }

        /* -----------------------------
       Category listing (top-level keys)
    ----------------------------- */
        function listCategories() {
          if (!dictionary || typeof dictionary !== "object") return [];
          return Object.keys(dictionary);
        }

        function listTerms(catName) {
          if (!dictionary || typeof dictionary !== "object") return null;
          const key = Object.keys(dictionary).find(
            (x) => x.toLowerCase() === catName.toLowerCase(),
          );
          if (!key) return null;

          const node = dictionary[key];
          if (!node || typeof node !== "object") return null;

          // terms at that category = keys under it (if object)
          return Object.keys(node).map((k) => ({
            term: k,
            def:
              typeof node[k] === "string" ||
              typeof node[k] === "number" ||
              typeof node[k] === "boolean"
                ? String(node[k])
                : "(nested)",
          }));
        }

        function randomTerm() {
          if (!searchIndex.length) return null;
          const itemsWithDefs = searchIndex.filter(
            (x) => x.def && x.def.trim().length > 0,
          );
          const pool = itemsWithDefs.length ? itemsWithDefs : searchIndex;
          return pool[Math.floor(Math.random() * pool.length)];
        }

        /* -----------------------------
       Render result cards
    ----------------------------- */
        function renderResults(items, title = "") {
          if (!items || items.length === 0) {
            addMessage("Not found. Try /search keyword or list categories.");
            return;
          }

          const html = `
        <div>
          ${title ? `<div class="crx-small" style="margin-bottom:6px;"><strong>${escHtml(title)}</strong></div>` : ""}
          ${items
            .map((r) => {
              const def =
                r.def && r.def.trim()
                  ? escHtml(r.def)
                  : "<span class='crx-small'>(no direct definition here ‚Äî nested node)</span>";
              return `
                <div style="margin-bottom:10px;">
                  <span class="crx-term">${escHtml(r.term)}</span>
                  <div class="crx-cat">${escHtml(r.path)}</div>
                  <div>${def}</div>
                </div>
              `;
            })
            .join("")}
        </div>
      `;
          addBotHtml(html);
        }

        /* -----------------------------
       Handle user input (improved)
    ----------------------------- */
        function handleUserText(text) {
          if (!dictionary) {
            addMessage("Dictionary not loaded yet.");
            return;
          }

          const raw = text.trim();
          const low = raw.toLowerCase();

          if (low === "help" || low === "/help") {
            addBotHtml(
              "<div class='crx-small'>Commands:<br>‚Ä¢ <code>/define term</code><br>‚Ä¢ <code>/search text</code><br>‚Ä¢ <code>list categories</code><br>‚Ä¢ <code>list categoryName</code><br>‚Ä¢ <code>/random</code></div>",
            );
            return;
          }

          if (low === "/random" || low === "random") {
            const r = randomTerm();
            if (!r) return addMessage("No data.");
            renderResults([r], "Random");
            return;
          }

          if (low === "list categories") {
            const cats = listCategories();
            addBotHtml(
              `<div class='crx-small'>${cats.map(escHtml).join("<br>")}</div>`,
            );
            return;
          }

          if (low.startsWith("list ")) {
            const cat = raw.slice(5);
            const terms = listTerms(cat);
            if (!terms) {
              addMessage("Category not found");
              return;
            }
            addBotHtml(
              `<div><strong>${escHtml(cat)}</strong><br>${terms.map((t) => escHtml(t.term)).join(", ")}</div>`,
            );
            return;
          }

          if (
            low.startsWith("/define ") ||
            low.startsWith("define ") ||
            low.startsWith("what is ")
          ) {
            const term = raw.replace(/^(\/define|define|what is)\s+/i, "");
            const res = searchEverywhere(term, 8);

            // prefer entries where term is exact
            const exact = res.filter(
              (r) => normalize(r.term) === normalize(term),
            );
            renderResults(exact.length ? exact : res, `Define: ${term}`);
            return;
          }

          if (low.startsWith("/search ")) {
            const q = raw.slice(8);
            const res = searchEverywhere(q, 10);
            renderResults(res, `Search: ${q}`);
            return;
          }

          // Greeting
          if (low.includes("hello") || low.includes("hi")) {
            addMessage(
              "Hello! Try /define recursion or /search stack or list categories",
            );
            return;
          }

          // Fallback: deep search everywhere
          const fb = searchEverywhere(raw, 10);
          if (fb.length) {
            renderResults(fb, `Results for: ${raw}`);
            return;
          }

          addMessage("Sorry, I couldn‚Äôt understand. Type help for commands.");
        }

        /* -----------------------------
       Events (unchanged)
    ----------------------------- */
        send.addEventListener("click", () => {
          const text = input.value.trim();
          if (!text) return;
          addMessage(text, "user");
          input.value = "";
          handleUserText(text);
        });

        input.addEventListener("keypress", (e) => {
          if (e.key === "Enter") send.click();
        });

        // Boot
        addBotHtml("Hello! Loading dictionary from <code>data.json</code>‚Ä¶");
        loadDictionary();
      })();
    </script>
  </body>
</html>
